-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- Decompilation Error: _glue_flows(node)

-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
slot3 = "CoreDebugManager"

core.module(slot1, core)

slot3 = "CoreEngineAccess"

core.import(slot1, core)

slot3 = "CoreSequenceManager"

core.import(slot1, core)

slot3 = "CoreDebug"

core.import(slot1, core)

slot3 = "CoreClass"

core.import(slot1, core)

slot3 = "CoreTable"

core.import(slot1, core)

slot3 = "CoreEngineAccess"

core.import(slot1, core)

DebugManager = DebugManager or class()
DebugManager.ROT_LINE_LENGTH = 20
DebugManager.reload = true
DebugManager.init = function (self)
	self._enabled = false
	self._enabled_paused = false
	DebugManager.reload = false
	self._system_list = {}
	slot4 = GUIDebug
	self._system_list.gui = GUIDebug.new(slot3)
	slot4 = FuncDebug
	self._system_list.func = FuncDebug.new(slot3)
	slot4 = PosDebug
	self._system_list.pos = PosDebug.new(slot3)
	slot4 = RotDebug
	self._system_list.rot = RotDebug.new(slot3)
	slot4 = GraphDebug
	self._system_list.graph = GraphDebug.new(slot3)
	slot4 = HijackDebug
	self._system_list.hijack = HijackDebug.new(slot3)
	slot4 = SimpleDebug
	self._system_list.simple = SimpleDebug.new(slot3)
	slot4 = PrintDebug
	self._system_list.print = PrintDebug.new(slot3)
	slot4 = ProfilerDebug
	self._system_list.profiler = ProfilerDebug.new(slot3)
	slot5 = self
	self._system_list.macro = MacroDebug.new(slot3, MacroDebug)
	slot4 = MemoryDebug
	self._system_list.mem = MemoryDebug.new(slot3)
	slot4 = ConsoleDebug
	self._system_list.console = ConsoleDebug.new(slot3)
	slot4 = MenuDebug
	self._system_list.menu = MenuDebug.new(slot3)
	slot3 = self._system_list

	for name, system in pairs(MenuDebug.new(slot3)) do
		self[name] = system
	end

	slot5 = 10

	self.pos.set_max_count(slot2, self.pos, "ray")

	slot5 = true

	self.pos.set_skip_lines(slot2, self.pos, "ray")

	return 
end
DebugManager.destroy = function (self)
	slot3 = self._system_list

	for _, system in pairs(slot2) do
		if system.destroy then
			slot8 = system

			system.destroy(slot7)
		end
	end

	return 
end
DebugManager.update = function (self, t, dt)
	if self._enabled then
		if DebugManager.reload then
			slot5 = self

			self.reloaded(slot4)
		end

		slot5 = self._system_list

		for _, system in pairs(slot4) do
			slot12 = dt

			system.update(slot9, system, t)
		end
	end

	return 
end
DebugManager.paused_update = function (self, t, dt)
	if self._enabled_paused then
		if DebugManager.reload then
			slot5 = self

			self.reloaded(slot4)
		end

		slot5 = self._system_list

		for _, system in pairs(slot4) do
			slot12 = dt

			system.paused_update(slot9, system, t)
		end
	end

	return 
end
DebugManager.reloaded = function (self)
	DebugManager.reload = false
	slot3 = self._system_list

	for _, system in pairs(false) do
		slot8 = system

		system.reloaded(slot7)
	end

	return 
end
DebugManager.clear = function (self, ...)
	slot3 = self._system_list

	for _, system in pairs(slot2) do
		slot8 = system

		system.clear(slot7, ...)
	end

	return 
end
DebugManager.toggle_enabled = function (self)
	slot4 = not self._enabled

	self.set_enabled(slot2, self)

	return 
end
DebugManager.toggle_enabled_paused = function (self)
	slot4 = not self._enabled_paused

	self.set_enabled_paused(slot2, self)

	return 
end
DebugManager.toggle_enabled_all = function (self)
	slot4 = not self._enabled

	self.set_enabled(slot2, self)

	slot4 = not self._enabled_paused

	self.set_enabled_paused(slot2, self)

	slot3 = self._system_list

	for _, system in pairs(slot2) do
		slot8 = system

		system.toggle_enabled(slot7)
	end

	return 
end
DebugManager.enabled = function (self)
	return self._enabled
end
DebugManager.enabled_paused = function (self)
	return self._enabled_paused
end
DebugManager.set_enabled = function (self, enabled)
	if self._enabled ~= enabled then
		if enabled then
			Global.render_debug.draw_enabled = true
		end

		self._enabled = enabled
	end

	return 
end
DebugManager.set_enabled_paused = function (self, enabled)
	if self._enabled_paused ~= enabled then
		if enabled then
			Global.render_debug.draw_enabled = true
		end

		self._enabled_paused = enabled
	end

	return 
end
DebugManager.set_systems_enabled = function (self, enabled, include_non_preferred)
	slot5 = self._system_list

	for system_name, system in pairs(slot4) do
		if include_non_preferred or not system.IS_PREFERRED_DISABLED then
			slot11 = enabled

			system.set_enabled(slot9, system)
		end
	end

	return 
end
DebugManager.set_enabled_all = function (self, enabled, include_non_preferred)
	slot6 = enabled

	self.set_enabled(slot4, self)

	slot6 = enabled

	self.set_enabled_paused(slot4, self)

	slot7 = include_non_preferred

	self.set_systems_enabled(slot4, self, enabled)

	return 
end
DebugManager.trim_list = function (list, max_count)
	if 0 < max_count then
		while max_count < #list do
			slot5 = 1

			table.remove(slot3, list)
		end
	end

	return 
end
DebugManager.draw_pos_list = function (list, skip_lines)
	local old_point = nil
	slot5 = list

	for index, point in ipairs(slot4) do
		slot14 = skip_lines

		DebugManager.draw_point(slot9, index, #list, old_point, point)

		old_point = point
	end

	return 
end
DebugManager.draw_point = function (index, count, old_point, point, skip_lines)
	local color = nil

	if point._color then
		color = point._color
	else
		slot9 = count
		color = DebugManager.get_color_by_index(slot7, index)
	end

	if not skip_lines and old_point then
		local dir = point._pos - old_point._pos.normalized(old_point._pos)
		slot11 = point._pos

		Application.draw_line_unpaused(point._pos - old_point._pos, Application, old_point._pos, unpack(slot13))

		slot12 = point._radius
		slot15 = color

		Application.draw_cone(point._pos - old_point._pos, Application, point._pos, point._pos - dir * point._radius * 2, unpack(color))
	else
		slot10 = point._radius
		slot13 = color

		Application.draw_sphere_unpaused(slot7, Application, point._pos, unpack(slot12))
	end

	return 
end
DebugManager.draw_rot_list = function (list)
	slot3 = list

	for index, point in ipairs(slot2) do
		local color = nil

		if point._color then
			color = point._color
		else
			slot10 = #list
			color = DebugManager.get_color_by_index(slot8, index)
		end

		slot11 = point._radius
		slot14 = color

		Application.draw_sphere_unpaused(slot8, Application, point._pos, unpack(slot13))

		slot14 = point._rot
		slot14 = 0

		Application.draw_line_unpaused(slot8, Application, point._pos, point._pos + point._rot.x(slot13) * DebugManager.ROT_LINE_LENGTH, 1, 0)

		slot14 = point._rot
		slot14 = 0

		Application.draw_line_unpaused(slot8, Application, point._pos, point._pos + point._rot.y(0) * DebugManager.ROT_LINE_LENGTH, 0, 1)

		slot14 = point._rot
		slot14 = 1

		Application.draw_line_unpaused(slot8, Application, point._pos, point._pos + point._rot.z(1) * DebugManager.ROT_LINE_LENGTH, 0, 0)
	end

	return 
end
DebugManager.get_color_by_index = function (index, count)
	local scale = nil

	if 1 < count then
		scale = (index - 1) / (count - 1)
	else
		scale = 0
	end

	slot5 = scale

	return DebugManager.get_color(slot4)
end
DebugManager.get_color = function (scale)
	if scale < 0.25 then
		slot5 = 0.25
		local b = DebugManager.get_interval_brightness(slot2, scale, 0)

		return {
			1,
			b,
			0
		}
	elseif scale < 0.5 then
		slot5 = 0.5
		local b = DebugManager.get_interval_brightness(slot2, scale, 0.25)

		return {
			1 - b,
			1,
			0
		}
	elseif scale < 0.75 then
		slot5 = 0.75
		local b = DebugManager.get_interval_brightness(slot2, scale, 0.5)

		return {
			0,
			1,
			b
		}
	else
		slot5 = 1
		local b = DebugManager.get_interval_brightness(slot2, scale, 0.75)

		return {
			0,
			1 - b,
			1
		}
	end

	return 
end
DebugManager.get_interval_brightness = function (scale, min, max)
	return (scale - min) / (max - min)
end
DebugManager.args_to_string = function (...)
	local s = ""
	slot3 = {
		...
	}

	for i, arg in pairs(slot2) do
		if 1 < i then
			slot10 = arg
			s = s .. "    " .. tostring(slot9)
		else
			slot8 = arg
			s = tostring(slot7)
		end
	end

	return s
end
DebugManager.qa_debug = function (self, username)
	return 
end
DebugPoint = DebugPoint or class()
DebugPoint.init = function (self, pos, rot, red, green, blue, radius)
	self._pos = pos
	self._rot = rot

	if red then
		self._color = {
			red or 1,
			green or 1,
			blue or 1
		}
	end

	self._radius = radius or 5

	return 
end
DebugFunction = DebugFunction or class()
DebugFunction.init = function (self, func, start_delay, interval, call_count)
	self._func = func
	slot7 = start_delay
	start_delay = tonumber(slot6)

	if start_delay then
		slot7 = TimerManager
		slot7 = TimerManager.wall(slot6)
		slot5 = TimerManager.wall(slot6).time(slot6) + start_delay
	end

	self._start_time = slot5
	slot7 = interval
	self._interval = tonumber(slot6)
	self._last_call_time = nil
	slot7 = call_count
	self._call_count = tonumber(slot6)

	return 
end
DebugFunction.update = function (self, t, dt)
	local can_start = not self._start_time or self._start_time <= t
	local interval_done = not self._last_call_time or not self._interval or self._interval <= t - self._last_call_time

	if can_start and interval_done then
		slot11 = self._interval
		local remove, new_interval, new_call_count = self._func(slot6, t, dt, self._num_calls_to_make, self._start_time)
		slot10 = new_interval
		self._interval = tonumber(self._num_calls_to_make) or self._interval
		slot10 = new_call_count
		self._call_count = tonumber(slot9) or self._call_count
		self._last_call_time = t

		if self._call_count then
			self._call_count = self._call_count - 1
			remove = remove or self._call_count <= 0
		end

		return remove
	else
		return false
	end

	return 
end
DebugRaycast = DebugRaycast or class()
DebugRaycast.MAX_ARROW_SIZE = 8
DebugRaycast.init = function (self, copy_ray_wrapper)

	-- Decompilation error in this vicinity:
	self._arrow_size = nil
	self._distance = nil

	if copy_ray_wrapper then
		slot4 = copy_ray_wrapper
		slot2 = copy_ray_wrapper.radius(slot3)
	end

	self._radius = slot2

	if copy_ray_wrapper then
		slot4 = copy_ray_wrapper
		slot2 = copy_ray_wrapper.bundle(slot3)
	end

	self._bundle = slot2
	self._to = slot2
	slot4 = self

	self.update_from_to_vars(slot3)

	return 
end
DebugRaycast.from = function (self)
	return self._from
end
DebugRaycast.set_from = function (self, from)
	self._from = from

	if self._to then
		slot4 = self._to - self._from
		self._dir = self._to - self._from.normalized(self._from)
	end

	return 
end
DebugRaycast.to = function (self)
	return self._to
end
DebugRaycast.set_to = function (self, to)
	self._to = to
	slot4 = self

	self.update_from_to_vars(slot3)

	return 
end
DebugRaycast.update_from_to_vars = function (self)
	if self._from and self._to then
		slot3 = self._to - self._from
		self._dir = self._to - self._from.normalized(self._from)
		slot3 = self._to - self._from
		self._distance = self._to - self._from.length(self._from)

		if self._distance < self.MAX_ARROW_SIZE then
			self._arrow_size = self._distance
		else
			self._arrow_size = self.MAX_ARROW_SIZE
		end
	end

	return 
end
DebugRaycast.radius = function (self)
	return self._radius
end
DebugRaycast.set_radius = function (self, radius)
	self._radius = radius

	return 
end
DebugRaycast.bundle = function (self)
	return self._bundle
end
DebugRaycast.set_bundle = function (self, bundle)
	self._bundle = bundle

	return 
end
DebugRaycast.color = function (self)
	return self._color
end
DebugRaycast.set_color = function (self, red, green, blue)
	self._color = {
		red or 1,
		green or 1,
		blue or 1
	}

	return 
end
DebugRaycast.normal = function (self)
	return self._normal
end
DebugRaycast.set_normal = function (self, normal)
	self._normal = normal

	return 
end
DebugRaycast.normal_color = function (self)
	return self._normal_color
end
DebugRaycast.set_normal_color = function (self, red, green, blue)
	self._normal_color = {
		red or 1,
		green or 1,
		blue or 1
	}

	return 
end
DebugRaycast.update = function (self, t, dt)
	if self._from and self._to then
		if self._radius then
			if self._bundle then
				slot7 = self._to
				slot10 = self._color

				Application.draw_line_unpaused(slot4, Application, self._from, unpack(slot9))

				slot5 = self._dir
				local orthogonal_func = self._dir.orthogonal_func(slot4)

				for i = 1, self._bundle - 1, 1 do
					local ratio = (i - 1) / (self._bundle - 1)
					local offset = orthogonal_func(slot10) * self._radius
					slot14 = self._to + offset
					slot17 = self._color

					Application.draw_line_unpaused(ratio, Application, self._from + offset, unpack(slot16))
				end
			else
				slot8 = self._radius
				slot11 = self._color

				Application.draw_cylinder(slot4, Application, self._from, self._to, unpack(slot10))

				slot7 = self._radius
				slot10 = self._color

				Application.draw_sphere_unpaused(slot4, Application, self._from, unpack(unpack))

				slot7 = self._radius
				slot10 = self._color

				Application.draw_sphere_unpaused(slot4, Application, self._to, unpack(unpack))
			end
		else
			slot7 = self._to
			slot10 = self._color

			Application.draw_line_unpaused(slot4, Application, self._from, unpack(slot9))
		end

		slot7 = self._arrow_size / 2

		Application.draw_sphere_unpaused(slot4, Application, self._from, unpack(slot9))

		slot8 = self._arrow_size / 2
		slot11 = self._color

		Application.draw_cone(slot4, Application, self._to, self._to - self._dir * self._arrow_size, unpack(self._color))

		if self._normal then
			slot7 = self._to + self._normal * 100
			slot10 = self._normal_color

			Application.draw_line_unpaused(slot4, Application, self._to, unpack(slot9))
		end
	end

	return 
end
DebugProfilerCounter = DebugProfilerCounter or class()
DebugProfilerCounter.init = function (self, name, index, obj, func_name, color, min, max, enabled, graph_enabled, gui_enabled, instance_override)
	self._instance_override = instance_override
	self._old_func = nil
	self._new_func = nil
	slot14 = name
	self._name = tostring(slot13)
	slot14 = index
	self._index = tonumber(slot13)
	self._obj = obj
	self._func_name = func_name
	self._enabled = false
	self._graph_enabled = false
	self._gui_enabled = false
	slot15 = color

	self.set_color(slot13, self)

	slot16 = max

	self.set_range(slot13, self, min)

	slot15 = enabled

	self.set_enabled(slot13, self)

	slot15 = graph_enabled

	self.set_graph_enabled(slot13, self)

	slot15 = gui_enabled

	self.set_gui_enabled(slot13, self)

	self._initialized = true

	if self._graph_enabled then
		slot14 = self

		self.update_graph(slot13)
	end

	slot14 = self

	self.update_gui(slot13)

	return 
end
DebugProfilerCounter.reload = function (self)
	if not self._instance_override and self._enabled then
		self._old_func = nil
		slot4 = false

		self.set_enabled(slot2, self)

		slot4 = true

		self.set_enabled(slot2, self)
	end

	return 
end
DebugProfilerCounter.name = function (self)
	return self._name
end
DebugProfilerCounter.index = function (self)
	return self._index
end
DebugProfilerCounter.set_index = function (self, index)
	if self._index and self._gui_enabled then
		slot6 = nil

		managers.debug.gui.set(slot3, managers.debug.gui, self._index)
	end

	slot4 = index
	self._index = tonumber(slot3)
	slot4 = self

	self.update_gui(slot3)

	return 
end
DebugProfilerCounter.enabled = function (self)
	return self._enabled
end
DebugProfilerCounter.set_enabled = function (self, enabled)
	enabled = not not enabled

	if self._enabled ~= enabled then
		if enabled then
			slot4 = self._obj
			local obj_class = getmetatable(slot3)

			if not obj_class then
				self._instance_override = true
				obj_class = self._obj
			end

			local meta_func = obj_class[self._func_name]
			local instance_func = self._obj[self._func_name]
			local name = self._name
			local old_func, obj = nil

			if self._instance_override or (self._instance_override == nil and meta_func ~= instance_func) then
				old_func = instance_func
				self._instance_override = true
				obj = self._obj
			else
				old_func = meta_func
				self._instance_override = false
				obj = obj_class
			end

			self._old_func = self._old_func or old_func
			self._new_func = function (...)
				local id = Profiler.start(slot1, Profiler)
				local return_list = {
					old_func(...)
				}
				slot5 = id

				Profiler.stop(name, Profiler)

				slot4 = return_list

				return unpack(name)
			end
			slot12 = self._new_func

			rawset(slot9, obj, self._func_name)

			slot11 = "profiler add " .. self._name

			Application.console_command(slot9, Application)
		else
			slot5 = "profiler remove " .. self._name

			Application.console_command(slot3, Application)

			if self._old_func then
				local obj = nil

				if self._instance_override then
					obj = self._obj
				else
					slot5 = self._obj
					obj = getmetatable(slot4)
				end

				slot7 = self._old_func

				rawset(slot4, obj, self._func_name)
			end
		end

		self._enabled = enabled
		slot4 = self

		self.update_graph(slot3)

		slot4 = self

		self.update_gui(slot3)
	end

	return 
end
DebugProfilerCounter.graph_enabled = function (self)
	return self._graph_enabled
end
DebugProfilerCounter.set_graph_enabled = function (self, enabled)
	enabled = not not enabled

	if self._graph_enabled ~= enabled then
		self._graph_enabled = enabled
		slot4 = self

		self.update_graph(slot3)

		slot4 = self

		self.update_gui(slot3)
	end

	return 
end
DebugProfilerCounter.gui_enabled = function (self)
	return self._gui_enabled
end
DebugProfilerCounter.set_gui_enabled = function (self, enabled)
	enabled = not not enabled

	if self._gui_enabled ~= enabled then
		if self._index and self._gui_enabled then
			slot6 = nil

			managers.debug.gui.set(slot3, managers.debug.gui, self._index)
		end

		self._gui_enabled = enabled
		slot4 = self

		self.update_gui(slot3)
	end

	return 
end
DebugProfilerCounter.range = function (self)
	return self._min, self._max
end
DebugProfilerCounter.set_range = function (self, min, max)
	slot5 = min
	self._min = tonumber(slot4) or 0
	slot8 = max
	slot6 = tonumber(slot7) or 100
	self._max = math.max(slot4, self._min)
	slot5 = self

	self.update_graph(slot4)

	return 
end
DebugProfilerCounter.color = function (self)
	return self._color
end
DebugProfilerCounter.set_color = function (self, color)
	if color and color.type_name ~= "Color" then
		color = nil
	end

	if not color then
		slot7 = 1
		slot2 = Color(slot3, 1, 1, 1)
	end

	self._color = slot2
	slot11 = 1
	slot12 = 1
	slot13 = 1
	slot9 = math.clamp(self._color.g, self._color.b, 0) * 15
	slot7 = math.round(math.clamp(self._color.r, self._color.g, 0) * 15) / 15
	self._color = Color(slot3, self._color.a, math.round(slot6) / 15, math.round(math.clamp(slot8, self._color.r, 0) * 15) / 15)
	slot4 = self

	self.update_graph(slot3)

	slot4 = self

	self.update_gui(slot3)

	return 
end
DebugProfilerCounter.update_graph = function (self)
	if self._initialized then
		if self._enabled and self._graph_enabled then
			slot12 = self._color.b * 15
			slot4 = "graph counter " .. self._name .. " color " .. string.format(slot8, "%X%X%X", self._color.r * 15, self._color.g * 15) .. " range " .. self._min .. " " .. self._max

			Application.console_command(slot2, Application)
		else
			slot4 = "graph hide " .. self._name

			Application.console_command(slot2, Application)
		end
	end

	return 
end
DebugProfilerCounter.update_gui = function (self)
	if self._initialized and self._index and self._gui_enabled then
		slot5 = nil

		managers.debug.gui.set(slot2, managers.debug.gui, self._index)

		if self._enabled and self._graph_enabled then
			slot5 = self._name

			managers.debug.gui.set(slot2, managers.debug.gui, self._index)

			slot8 = self._color.a

			managers.debug.gui.set_color(slot2, managers.debug.gui, self._index, self._color.r, self._color.g, self._color.b)
		end
	end

	return 
end
BaseDebug = BaseDebug or class()
BaseDebug.init = function (self)
	self._enabled = false

	return 
end
BaseDebug.clear = function (self)
	return 
end
BaseDebug.update = function (self, t, dt)
	return 
end
BaseDebug.paused_update = function (self, t, dt)
	slot7 = dt

	self.update(slot4, self, t)

	return 
end
BaseDebug.set_enabled = function (self, enabled)
	self._enabled = enabled

	return 
end
BaseDebug.get_enabled = function (self)
	return self._enabled
end
BaseDebug.toggle_enabled = function (self)
	slot4 = not self._enabled

	self.set_enabled(slot2, self)

	return 
end
BaseDebug.reloaded = function (self)
	return 
end

if not FuncDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

FuncDebug = slot0
FuncDebug.init = function (self)
	slot3 = self

	FuncDebug.super.init(slot2)

	self._func_list = {}

	return 
end
FuncDebug.update = function (self, t, dt)
	slot5 = self._func_list

	for index, wrapped_func in pairs(slot4) do
		slot12 = dt

		if wrapped_func.update(slot9, wrapped_func, t) then
			slot11 = index

			self.remove(slot9, self)
		end
	end

	return 
end
FuncDebug.clear = function (self)
	slot3 = self

	FuncDebug.super.clear(slot2)

	self._func_list = {}

	return 
end
FuncDebug.add = function (self, func, start_delay, interval, call_count)
	slot12 = call_count

	self.set(slot6, self, #self._func_list + 1, func, start_delay, interval)

	return 
end
FuncDebug.set = function (self, index, func, start_delay, interval, call_count)
	index = index or 1

	if func then
		slot8 = func

		if type(slot7) == "function" then
			slot13 = call_count
			self._func_list[index] = DebugFunction.new(slot8, DebugFunction, func, start_delay, interval)
		else
			slot12 = func
			slot14 = index
			slot9 = "Tried to set invalid function \"" .. tostring(slot11) .. "\" to index \"" .. tostring(slot13) .. "\"."

			cat_error(slot7, "debug")
		end
	else
		slot9 = index

		self.remove(slot7, self)
	end

	return 
end
FuncDebug.delete = function (self, func, all)
	local count = 0
	slot6 = self._func_list

	for index, wrapped_func in ipairs(slot5) do
		slot11 = wrapped_func

		if wrapped_func.get_func(slot10) == func then
			slot12 = index

			self.remove(slot10, self)

			count = count + 1

			if not all then
				break
			end
		end
	end

	return count
end
FuncDebug.remove = function (self, index)
	self._func_list[index] = nil

	return 
end

if not PosDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

PosDebug = slot0
PosDebug.init = function (self)
	slot3 = self

	PosDebug.super.init(slot2)

	self._pos_list = {}
	self._max_pos_count = 200
	self._max_pos_count_map = {}
	self._skip_lines_map = {}

	return 
end
PosDebug.update = function (self, t, dt)
	slot5 = self._pos_list

	for list_index, list in pairs(slot4) do
		slot11 = self._skip_lines_map[list_index]

		DebugManager.draw_pos_list(slot9, list)
	end

	return 
end
PosDebug.clear = function (self, list_index)
	slot4 = self

	PosDebug.super.clear(slot3)

	if not list_index then
		self._pos_list = {}
	else
		self._pos_list[list_index] = nil
	end

	return 
end
PosDebug.get_skip_lines = function (self, list_index)
	return self._skip_lines_map[list_index]
end
PosDebug.set_skip_lines = function (self, list_index, skip_lines)
	self._skip_lines_map[list_index] = skip_lines

	return 
end
PosDebug.add = function (self, pos, list_index, red, green, blue, radius)
	list_index = list_index or 1
	slot13 = list_index
	slot16 = radius

	self.set(slot8, self, self.get_count(slot11, self) + 1, pos, list_index, red, green, blue)

	return 
end
PosDebug.add_list = function (self, list, list_index, red, green, blue, radius)
	slot9 = list

	for index, point in ipairs(slot8) do
		slot21 = radius

		self.set(slot13, self, index, point, list_index, red, green, blue)
	end

	return 
end
PosDebug.set = function (self, index, pos, list_index, red, green, blue, radius)
	return 
end
PosDebug.remove = function (self, index, list_index)

	-- Decompilation error in this vicinity:
	list_index = list_index or 1

	if self._pos_list[list_index] then
		slot6 = index

		table.remove(slot4, self._pos_list[list_index])

		if #self._pos_list[list_index] == 0 then
			self._pos_list[list_index] = nil
		end
	end

	return 
end
PosDebug.get = function (self, index, list_index)
	list_index = list_index or 1

	if self._pos_list[list_index] and 0 < #self._pos_list[list_index] then
		return (index and self._pos_list[list_index][index]) or self._pos_list[list_index][#self._pos_list[list_index]]
	end

	return nil
end
PosDebug.get_count = function (self, list_index)
	if list_index then
		if self._pos_list[list_index] then
			return #self._pos_list[list_index]
		else
			return 0
		end
	else
		return #self._pos_list
	end

	return 
end
PosDebug.get_max_count = function (self, list_index)
	return (list_index and self._max_pos_count_map[list_index]) or self._max_pos_count
end
PosDebug.set_max_count = function (self, list_index, max_count)
	if list_index then
		slot6 = max_count
		self._max_pos_count_map[list_index] = tonumber(slot5)
	else
		slot5 = max_count
		self._max_pos_count = tonumber(slot4) or self._max_pos_count
	end

	slot5 = self._pos_list

	for list_index, list in pairs(slot4) do
		slot10 = list
		slot14 = list_index

		DebugManager.trim_list(slot9, self.get_max_count(slot12, self))
	end

	return 
end

if not RotDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

RotDebug = slot0
RotDebug.init = function (self)
	slot3 = self

	RotDebug.super.init(slot2)

	self._rot_list = {}
	self._max_rot_count = 200
	self._max_rot_count_map = {}

	return 
end
RotDebug.update = function (self, t, dt)
	slot5 = self._rot_list

	for _, list in pairs(slot4) do
		slot10 = list

		DebugManager.draw_rot_list(slot9)
	end

	return 
end
RotDebug.clear = function (self, list_index)
	slot4 = self

	RotDebug.super.clear(slot3)

	if not list_index then
		self._rot_list = {}
	else
		self._rot_list[list_index] = nil
	end

	return 
end
RotDebug.add = function (self, pos, list_index, rot, red, green, blue, radius)
	list_index = list_index or 1
	slot14 = list_index
	slot18 = radius

	self.set(slot9, self, self.get_count(slot12, self) + 1, pos, list_index, rot, red, green, blue)

	return 
end
RotDebug.set = function (self, index, pos, list_index, rot, red, green, blue, radius)
	if pos then
		slot11 = pos
	elseif rot then
		slot11 = rot
	else
		local point = nil

		if pos and rot then
			slot18 = radius
			point = DebugPoint.new(slot11, DebugPoint, pos, rot, red, green, blue)
		end

		list_index = list_index or 1
		self._rot_list[list_index] = self._rot_list[list_index] or {}
		self._rot_list[list_index][index] = point
		slot13 = self._max_rot_count

		DebugManager.trim_list(self._rot_list[list_index] or , self._rot_list[list_index])
	end

	return 
end
RotDebug.remove = function (self, index, list_index)
	list_index = list_index or 1

	if self._rot_list[list_index] then
		slot6 = index

		table.remove(slot4, self._rot_list[list_index])

		if #self._rot_list[list_index] == 0 then
			self._rot_list[list_index] = nil
		end
	end

	return 
end
RotDebug.get_count = function (self, list_index)
	if list_index then
		if self._rot_list[list_index] then
			return #self._rot_list[list_index]
		else
			return 0
		end
	else
		return #self._rot_list
	end

	return 
end
RotDebug.get_max_count = function (self, list_index)
	return (list_index and self._max_rot_count_map[list_index]) or self._max_rot_count
end
RotDebug.set_max_count = function (self, list_index, max_count)
	if list_index then
		slot6 = max_count
		self._max_rot_count_map[list_index] = tonumber(slot5)
	else
		slot5 = max_count
		self._max_rot_count = tonumber(slot4) or self._max_rot_count
	end

	slot5 = self._rot_list

	for list_index, list in pairs(slot4) do
		slot10 = list
		slot14 = list_index

		DebugManager.trim_list(slot9, self.get_max_count(slot12, self))
	end

	return 
end

if not GUIDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

GUIDebug = slot0
GUIDebug.GUI_TEXT_COUNT = 60
GUIDebug.init = function (self)
	slot3 = self

	GUIDebug.super.init(slot2)

	self._text_func = {}

	return 
end
GUIDebug.destroy = function (self)
	slot3 = self._workspace

	if alive(slot2) then
		slot3 = Overlay
		slot4 = self._workspace

		Overlay.gui(slot2).destroy_workspace(slot2, Overlay.gui(slot2))

		self._workspace = nil
	end

	return 
end
GUIDebug.update = function (self, t, dt)
	slot5 = self._text_func

	for index, func in pairs(slot4) do
		slot13 = dt
		local s = DebugManager.args_to_string(func(slot11, t))
		slot12 = s

		self._text[index].set_text(func, self._text[index])
	end

	return 
end
GUIDebug.clear = function (self)
	slot3 = self

	GUIDebug.super.clear(slot2)

	if self._workspace ~= nil then
		slot3 = self._text

		for _, text in ipairs(slot2) do
			slot9 = ""

			text.set_text(slot7, text)

			slot8 = text
			slot13 = 0

			text.set_color(slot7, Color(slot10, 1, 0))
		end

		slot3 = self._workspace
		slot3 = self._workspace.panel(slot2)

		self._workspace.panel(slot2).clear(slot2)

		slot3 = Overlay
		slot4 = self._workspace

		Overlay.gui(slot2).destroy_workspace(slot2, Overlay.gui(slot2))

		self._workspace = nil
		self._panel = nil
		self._text = nil
		self._text_func = {}
	end

	return 
end
GUIDebug.set_enabled = function (self, enabled)
	if self._workspace and self._enabled ~= enabled then
		if enabled then
			slot4 = self._workspace

			self._workspace.show(slot3)
		else
			slot4 = self._workspace

			self._workspace.hide(slot3)
		end
	end

	slot5 = enabled

	BaseDebug.set_enabled(slot3, self)

	return 
end
GUIDebug.setup = function (self)
	local gui_scene = Overlay.gui(slot2)
	slot4 = gui_scene
	self._workspace = gui_scene.create_screen_workspace(Overlay)
	slot4 = self._workspace
	slot7 = "core/guis/core_debug_manager"
	local gui = self._workspace.panel(Overlay).gui(Overlay, Idstring(slot6))
	self._panel = gui.panel(self._workspace.panel(Overlay))
	self._text = {}
	local config = {
		font = "core/fonts/diesel",
		font_size = 16
	}
	slot8 = 0
	config.color = Color(gui, 255, 0)
	config.x = 45
	config.y = 25
	config.layer = 1000000

	for i = 1, self.GUI_TEXT_COUNT, 1 do
		slot12 = config
		self._text[i] = self._panel.text(slot10, self._panel)
		slot11 = self._text[i]
		config.y = config.y + self._text[i].line_height(slot10)
	end

	if self._enabled then
		slot6 = self._workspace

		self._workspace.show(slot5)
	else
		slot6 = self._workspace

		self._workspace.hide(slot5)
	end

	return 
end
GUIDebug.set_func = function (self, index, func)
	if 1 <= index and index <= self.GUI_TEXT_COUNT then
		if self._workspace == nil then
			slot5 = self

			self.setup(slot4)
		end

		self._text_func[index] = func
	end

	return 
end
GUIDebug.get = function (self, index)
	if 1 <= index and index <= self.GUI_TEXT_COUNT then
		if self._workspace == nil then
			slot4 = self

			self.setup(slot3)
		end

		if self._text_func[index] then
			slot6 = TimerManager
			slot4 = TimerManager.wall(slot5).time(slot5)
			slot7 = TimerManager
			slot7 = TimerManager.wall(TimerManager.wall(slot5))

			return self._text_func[index](slot3, TimerManager.wall(TimerManager.wall(slot5)).delta_time(TimerManager.wall(slot5)))
		elseif self._text[index] then
			slot4 = self._text[index]

			return self._text[index].text(slot3)
		else
			return nil
		end
	end

	return 
end
GUIDebug.set = function (self, index, ...)
	if 1 <= index and index <= self.GUI_TEXT_COUNT then
		if self._workspace == nil then
			slot4 = self

			self.setup(slot3)
		end

		local s = DebugManager.args_to_string(...)
		slot6 = s

		self._text[index].set_text(slot4, self._text[index])

		self._text_func[index] = nil
	end

	return 
end
GUIDebug.get = function (self, index)
	if 1 <= index and index <= self.GUI_TEXT_COUNT then
		if self._workspace == nil then
			slot4 = self

			self.setup(slot3)
		end

		slot4 = self._text[index]

		return self._text[index].text(slot3)
	end

	return 
end
GUIDebug.set_color = function (self, index, red, green, blue, alpha)
	if 1 <= index and index <= self.GUI_TEXT_COUNT then
		if self._workspace == nil then
			slot8 = self

			self.setup(slot7)
		end

		slot8 = self._text[index]
		slot14 = 1
		slot14 = blue or 1

		self._text[index].set_color(slot7, Color(slot10, math.min(slot12, alpha or 1), red or 1, green or 1))
	end

	return 
end

if not GraphDebug then
	slot2 = PosDebug
	slot0 = class(slot1)
end

GraphDebug = slot0
GraphDebug.AXIS_ARROW_SIZE = 20
GraphDebug.GUI_WORLD_WIDTH = 1000
GraphDebug.GUI_WORLD_HEIGHT = 250
GraphDebug.init = function (self)
	slot3 = self

	GraphDebug.super.init(slot2)

	self._size = 500
	slot5 = 200
	self._cam_offset = Vector3(slot2, 0, 1000)
	self._is_fixed_rot = false
	self._fixed_rot = nil
	self._invalidated = true
	self._max_x = nil
	self._min_x = nil
	self._max_y = nil
	self._min_y = nil
	self._max_z = nil
	self._min_z = nil
	self._span_x = nil
	self._span_y = nil
	self._span_z = nil
	self._scale_x = nil
	self._scale_y = nil
	self._scale_z = nil
	self._workspace_map = nil
	self._visible = false
	self._camera = nil
	self._fixed_range = nil

	return 
end
GraphDebug.set_fixed_range = function (self, fixed_range)
	self._fixed_range = fixed_range

	if fixed_range then
		slot9 = self._min_z or 0
		slot5 = Vector3(slot6, self._min_x or 0, self._min_y or 0)
		slot10 = self._max_z or 0

		self.set_range(slot3, self, Vector3(self._min_x or 0, self._max_x or 0, self._max_y or 0))
	end

	return 
end
GraphDebug.set_range = function (self, min, max)
	self._min_x = min.x
	self._max_x = max.x
	self._min_y = min.y
	self._max_y = max.y
	self._min_z = min.z
	self._max_z = max.z
	self._span_x = self._max_x - self._min_x
	self._span_y = self._max_y - self._min_y
	self._span_z = self._max_z - self._min_z

	if 0 < self._span_x then
		self._scale_x = self._size / self._span_x
	else
		self._scale_x = 0
	end

	if 0 < self._span_y then
		self._scale_y = self._size / self._span_y
	else
		self._scale_y = 0
	end

	if 0 < self._span_z then
		self._scale_z = self._size / self._span_z
	else
		self._scale_z = 0
	end

	return 
end
GraphDebug.update = function (self, t, dt)
	slot5 = self._pos_list

	if next(slot4) then
		if not self._workspace_map then
			slot5 = self

			self.setup(slot4)
		end

		if not self._camera and managers.viewport then
			slot5 = managers.viewport
			local camera = managers.viewport.get_current_camera(slot4)
		end

		local rotation, origo = nil

		if camera then
			slot8 = camera
			rotation = camera.rotation(slot7)
			slot9 = rotation
			slot9 = rotation
			origo = camera.position(slot7) + rotation.y(camera) * self._cam_offset.y + rotation.z(self._cam_offset.y) * self._cam_offset.z

			if not self._fixed_rot then
			end
		else
			origo = Vector3()
			rotation = self._fixed_rot or Rotation()
		end

		if self._invalidated then
			if not self._fixed_range then
				local min_x = 0
				local max_x = 0
				local min_y = 0
				local max_y = 0
				local min_z = 0
				local max_z = 0
				slot14 = self._pos_list

				for list_index, list in pairs(slot13) do
					slot19 = list

					for index, point in ipairs(slot18) do
						if point._pos.x < min_x then
							min_x = point._pos.x
						end

						if max_x < point._pos.x then
							max_x = point._pos.x
						end

						if point._pos.y < min_y then
							min_y = point._pos.y
						end

						if max_y < point._pos.y then
							max_y = point._pos.y
						end

						if point._pos.z < min_z then
							min_z = point._pos.z
						end

						if max_z < point._pos.z then
							max_z = point._pos.z
						end
					end
				end

				slot19 = min_z
				slot15 = Vector3(slot16, min_x, min_y)
				slot20 = max_z

				self.set_range(slot13, self, Vector3(min_x, max_x, max_y))
			end

			self._invalidated = false
		end

		slot10 = self._min_z + self._span_z / 2
		local offset = Vector3(slot7, self._min_x + self._span_x / 2, self._min_y + self._span_y / 2)
		slot10 = offset
		slot10 = rotation
		local offset_origo = origo - self.get_scaled_pos(self._min_x + self._span_x / 2, self).rotate_with(self._min_x + self._span_x / 2, self.get_scaled_pos(self._min_x + self._span_x / 2, self))
		slot12 = 0
		slot11 = rotation
		local offset_max_x = offset_origo + Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0).rotate_with(self.get_scaled_pos(self._min_x + self._span_x / 2, self), Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0))
		slot13 = 0
		slot12 = rotation
		local offset_max_y = offset_origo + Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y).rotate_with(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y))
		slot14 = self._max_z * self._scale_z
		slot13 = rotation
		local offset_max_z = offset_origo + Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0).rotate_with(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0))
		slot15 = 0
		slot14 = rotation
		local offset_min_x = offset_origo + Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0).rotate_with(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0))
		slot16 = 0
		slot15 = rotation
		local offset_min_y = offset_origo + Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y).rotate_with(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y))
		slot17 = self._min_z * self._scale_z
		slot16 = rotation
		local offset_min_z = offset_origo + Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0).rotate_with(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0))
		slot21 = 0

		Application.draw_line_unpaused(Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0), Application, offset_min_x, offset_max_x, 1, 0)

		slot21 = 0

		Application.draw_line_unpaused(Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0), Application, offset_min_y, offset_max_y, 0, 1)

		slot21 = 1

		Application.draw_line_unpaused(Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0), Application, offset_min_z, offset_max_z, 0, 0)

		slot21 = 0
		slot20 = rotation
		slot22 = 0

		Application.draw_cone(Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0), Application, offset_max_x + Vector3(offset_max_z, GraphDebug.AXIS_ARROW_SIZE, 0).rotate_with(offset_max_z, Vector3(offset_max_z, GraphDebug.AXIS_ARROW_SIZE, 0)), offset_max_x, GraphDebug.AXIS_ARROW_SIZE / 4, 1, 0)

		slot21 = 0
		slot20 = rotation
		slot22 = 0

		Application.draw_cone(Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0), Application, offset_max_y + Vector3(offset_max_x, 0, GraphDebug.AXIS_ARROW_SIZE).rotate_with(offset_max_x, Vector3(offset_max_x, 0, GraphDebug.AXIS_ARROW_SIZE)), offset_max_y, GraphDebug.AXIS_ARROW_SIZE / 4, 0, 1)

		slot21 = GraphDebug.AXIS_ARROW_SIZE
		slot20 = rotation
		slot22 = 1

		Application.draw_cone(Vector3(Vector3(Vector3(Vector3(Vector3(Vector3(self.get_scaled_pos(self._min_x + self._span_x / 2, self), self._max_x * self._scale_x, 0), 0, self._max_y * self._scale_y), 0, 0), self._min_x * self._scale_x, 0), 0, self._min_y * self._scale_y), 0, 0), Application, offset_max_z + Vector3(offset_max_y, 0, 0).rotate_with(offset_max_y, Vector3(offset_max_y, 0, 0)), offset_max_z, GraphDebug.AXIS_ARROW_SIZE / 4, 0, 0)

		local old_point = nil
		slot17 = self._pos_list

		for list_index, list in pairs(Application) do
			old_point = nil
			slot22 = list

			for index, point in ipairs(slot21) do
				local graph_point = CoreTable.clone(slot26)
				slot29 = point._pos
				slot29 = rotation
				graph_point._pos = offset_origo + self.get_scaled_pos(point, self).rotate_with(point, self.get_scaled_pos(point, self))
				slot32 = self._skip_lines_map[list_index]

				DebugManager.draw_point(point, index, #list, old_point, graph_point)

				old_point = graph_point
			end
		end

		slot22 = self._max_x

		self.set_gui_text(slot16, self, "max_x", offset_max_x, rotation, "")

		slot22 = -rotation.x(slot23)
		slot25 = rotation
		slot22 = self._max_y

		self.set_gui_text(slot16, self, "max_y", offset_max_y, Rotation("", rotation.z(rotation)), "")

		slot22 = self._max_z

		self.set_gui_text(slot16, self, "max_z", offset_max_z, rotation, "")

		slot22 = self._min_x

		self.set_gui_text(slot16, self, "min_x", offset_min_x, rotation, "")

		slot22 = -rotation.x(rotation.z)
		slot25 = rotation
		slot22 = self._min_y

		self.set_gui_text(slot16, self, "min_y", offset_min_y, Rotation("", rotation.z(rotation)), "")

		slot22 = self._min_z

		self.set_gui_text(slot16, self, "min_z", offset_min_z, rotation, "")

		slot18 = true

		self.set_visible(slot16, self)
	elseif self._workspace_map then
		slot6 = false

		self.set_visible(slot4, self)
	end

	return 
end
GraphDebug.set_gui_text = function (self, id, position, rotation, label, value)
	local workspace = self._workspace_map[id]
	slot9 = workspace
	slot10 = 0
	local gui_text = workspace.panel(slot8).child(slot8, workspace.panel(slot8))
	slot10 = gui_text
	slot15 = value

	gui_text.set_text(workspace.panel(slot8), string.format(slot12, "%s%g", label))

	local w, h = self.get_text_size(workspace.panel(slot8), self)

	gui_text.set_world_shape(gui_text, gui_text, self.GUI_WORLD_WIDTH / 2 - w, self.GUI_WORLD_HEIGHT / 2 - h, w * 2)

	slot19 = -self.GUI_WORLD_HEIGHT / 2
	slot18 = rotation
	slot19 = rotation
	slot17 = -rotation.z(rotation) * self.GUI_WORLD_HEIGHT

	workspace.set_world(gui_text, workspace, self.GUI_WORLD_WIDTH, self.GUI_WORLD_HEIGHT, position - Vector3(h * 2, self.GUI_WORLD_WIDTH / 2, 0).rotate_with(h * 2, Vector3(h * 2, self.GUI_WORLD_WIDTH / 2, 0)), rotation.x(Vector3(h * 2, self.GUI_WORLD_WIDTH / 2, 0)) * self.GUI_WORLD_WIDTH)

	return 
end
GraphDebug.get_text_size = function (self, gui_text)
	local w = 0
	local h = 0
	slot7 = gui_text

	for i = 1, #gui_text.text(slot6), 1 do
		slot11 = i - 1
		local char_x, char_y, char_w, char_h = gui_text.character_rect(slot9, gui_text)
		w = w + char_w
		slot15 = char_h
		h = math.max(slot13, h)
	end

	return w, h
end
GraphDebug.get_scaled_pos = function (self, pos)
	slot6 = pos.z * self._scale_z

	return Vector3(slot3, pos.x * self._scale_x, pos.y * self._scale_y)
end
GraphDebug.setup = function (self)
	self._workspace_map = {}
	local text_config = {
		font = "core/fonts/diesel",
		font_size = 50
	}
	slot6 = 0
	text_config.color = Color(slot3, 1, 0)
	text_config.vertical = "bottom"
	text_config.align = "left"
	slot6 = text_config

	self.create_gui_text(slot3, self, "min_x")

	text_config.align = "right"
	slot6 = text_config

	self.create_gui_text(slot3, self, "max_x")

	slot6 = 0
	text_config.color = Color(slot3, 0, 1)
	slot6 = text_config

	self.create_gui_text(slot3, self, "max_y")

	text_config.align = "left"
	slot6 = text_config

	self.create_gui_text(slot3, self, "min_y")

	slot6 = 1
	text_config.color = Color(slot3, 0, 0)
	text_config.align = "right"
	slot6 = text_config

	self.create_gui_text(slot3, self, "min_z")

	text_config.vertical = "top"
	slot6 = text_config

	self.create_gui_text(slot3, self, "max_z")

	return 
end
GraphDebug.get_camera = function (self)
	return self._camera
end
GraphDebug.set_camera = function (self, camera)
	self._camera = camera

	return 
end
GraphDebug.create_gui_text = function (self, id, config)
	slot5 = World
	slot13 = 0
	slot9 = Vector3(slot10, 1, 0)
	slot14 = 1
	local workspace = World.gui(slot4).create_world_workspace(slot4, World.gui(slot4), self.GUI_WORLD_WIDTH, self.GUI_WORLD_HEIGHT, Vector3(), Vector3(1, 0, 0))
	self._workspace_map[id] = workspace
	slot6 = workspace
	slot7 = config
	local gui_text = workspace.panel(World.gui(slot4)).text(World.gui(slot4), workspace.panel(World.gui(slot4)))
	slot7 = workspace

	workspace.hide(workspace.panel(World.gui(slot4)))

	return 
end
GraphDebug.clear = function (self, list_index)
	slot5 = list_index

	GraphDebug.super.clear(slot3, self)

	self._invalidated = true

	return 
end
GraphDebug.set_size = function (self, size)
	self._size = size
	self._invalidated = true

	return 
end
GraphDebug.get_size = function (self)
	return self._size
end
GraphDebug.set_offset = function (self, offset)
	self._cam_offset = offset

	return 
end
GraphDebug.get_offset = function (self)
	return self._cam_offset
end
GraphDebug.set_is_fixed_rot = function (self, is_fixed_rot)
	self._is_fixed_rot = is_fixed_rot

	return 
end
GraphDebug.is_fixed_rot = function (self)
	return self._is_fixed_rot
end
GraphDebug.set_fixed_rot = function (self, fixed_rot)
	self._fixed_rot = fixed_rot

	return 
end
GraphDebug.get_fixed_rot = function (self)
	return self._fixed_rot
end
GraphDebug.set = function (self, index, pos, list_index, red, green, blue, radius)
	list_index = list_index or 1
	slot10 = pos

	if type(slot9) == "number" then
		slot11 = list_index
		local count = self.get_count(slot9, self)
		slot12 = list_index
		local max_count = self.get_max_count(self, self)
		slot13 = list_index
		local x = self.get_count(self, self)

		if max_count ~= -1 and max_count <= count then
			slot15 = count - max_count + 1

			self.scroll_number_list(slot12, self, list_index)

			x = x - 1
		end

		slot15 = pos
		pos = Vector3(slot12, x, 0)
	end

	slot17 = radius or 0

	GraphDebug.super.set(slot9, self, index, pos, list_index, red, green, blue)

	self._invalidated = true

	return 
end
GraphDebug.set_max_count = function (self, list_index, max_count)
	if list_index then
		local list = self._pos_list[list_index]

		if list and max_count < #list then
			slot8 = #list - max_count - 1

			self.scroll_number_list(slot5, self, list_index)

			self._invalidated = true
		end
	else
		slot5 = self._pos_list

		for list_index, list in pairs(slot4) do
			if max_count < #list then
				slot12 = #list - max_count - 1

				self.scroll_number_list(slot9, self, list_index)

				self._invalidated = true
			end
		end
	end

	slot7 = max_count

	GraphDebug.super.set_max_count(slot4, self, list_index)

	return 
end
GraphDebug.scroll_number_list = function (self, list_index, scroll)
	slot5 = self._pos_list[list_index]

	for _, point in ipairs(slot4) do
		slot12 = point._pos.z
		point._pos = Vector3(slot9, point._pos.x - scroll, point._pos.y)
	end

	return 
end
GraphDebug.remove = function (self, list_index, ...)
	slot5 = list_index

	GraphDebug.super.remove(slot3, self, ...)

	self._invalidated = true

	return 
end
GraphDebug.set_enabled = function (self, enabled)
	if self._enabled ~= enabled then
		if enabled then
			if not self._workspace_map then
				slot4 = self

				self.setup(slot3)
			end

			slot5 = true

			self.set_visible(slot3, self)
		elseif self._workspace_map then
			slot5 = false

			self.set_visible(slot3, self)
		end
	end

	slot5 = enabled

	GraphDebug.super.set_enabled(slot3, self)

	return 
end
GraphDebug.set_visible = function (self, visible)
	if not self._visible ~= not visible then
		self._visible = visible
		slot4 = self._workspace_map

		for _, workspace in pairs(slot3) do
			if visible then
				slot9 = workspace

				workspace.show(slot8)
			else
				slot9 = workspace

				workspace.hide(slot8)
			end
		end
	end

	return 
end

if not HijackDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

HijackDebug = slot0
HijackDebug.init = function (self)
	slot3 = self

	HijackDebug.super.init(slot2)

	self._ray_list = {}
	self._hijack_ray_enabled = false
	self._old_func_list = {}
	slot5 = "default_hijacked_ray_func"
	self._hijack_ray_func = callback(slot2, self, self)
	self._ray_obj_list = {}
	slot4 = World
	self._ray_obj_list[World.key(self)] = World
	self._hijacked_statemachine_map = nil

	return 
end
HijackDebug.update = function (self, t, dt)
	slot5 = self._ray_list

	for _, ray in pairs(slot4) do
		slot12 = dt

		ray.update(slot9, ray, t)
	end

	return 
end
HijackDebug.clear = function (self)
	slot3 = self

	HijackDebug.super.clear(slot2)

	self._ray_list = {}

	return 
end
HijackDebug.add_ray_obj = function (self, obj)
	if obj.key then
		slot5 = obj
		self._ray_obj_list[obj.key(slot4)] = obj

		if self._hijack_ray_enabled then
			slot6 = true

			self.set_hijack_ray_obj(slot3, self, obj)
		end
	end

	return 
end
HijackDebug.delete_ray_obj = function (self, obj)
	if obj.key then
		slot5 = obj
		self._ray_obj_list[obj.key(slot4)] = nil

		if self._hijack_ray_enabled then
			slot6 = false

			self.set_hijack_ray_obj(slot3, self, obj)
		end
	end

	return 
end
HijackDebug.reset_ray_obj_list = function (self)
	self.clear_ray_obj_list(slot2)

	slot4 = World
	self._ray_obj_list[World.key(self)] = World

	return 
end
HijackDebug.clear_ray_obj_list = function (self)
	slot3 = self._ray_obj_list

	for _, obj in pairs(slot2) do
		slot9 = obj

		self.delete_ray_obj(slot7, self)
	end

	return 
end
HijackDebug.ray_enabled = function (self)
	return self._hijack_ray_enabled
end
HijackDebug.set_ray_enabled = function (self, enabled)
	if self._hijack_ray_enabled ~= enabled then
		self._hijack_ray_enabled = enabled
		slot4 = self._ray_obj_list

		for _, obj in pairs(slot3) do
			slot11 = enabled

			self.set_hijack_ray_obj(slot8, self, obj)
		end
	end

	return 
end
HijackDebug.set_hijack_ray_obj = function (self, obj, enabled)
	return 
end
HijackDebug.is_hijack_ray_obj = function (self, obj)
end
HijackDebug.set_hijack_ray_func = function (self, func)

	-- Decompilation error in this vicinity:
	if func then
		self._hijack_ray_func = func
	else
		slot6 = "default_hijacked_ray_func"
		self._hijack_ray_func = callback(slot3, self, self)
	end

	return 
end
HijackDebug.hijacked_ray = function (self, obj, ...)
	slot5 = obj

	if self._old_func_list[obj.key(slot4)] then
		slot8 = obj
		slot5 = self._old_func_list[obj.key(slot7)]

		return self._hijack_ray_func(slot3, obj, ...)
	else
		return nil
	end

	return 
end
HijackDebug.default_hijacked_ray_func = function (self, obj, old_func, ...)
	local param_list = {
		...
	}
	slot6 = obj
	local ray = old_func(slot5, ...)
	local point_list = nil
	slot8 = DebugRaycast
	local ray_wrapper = DebugRaycast.new(slot7)

	if ray then
		slot10 = ray.position - ray.ray * ray.distance

		ray_wrapper.set_from(slot8, ray_wrapper)

		slot10 = ray.position

		ray_wrapper.set_to(slot8, ray_wrapper)

		slot12 = 0

		ray_wrapper.set_color(slot8, ray_wrapper, 1, 0)

		slot10 = ray.normal

		ray_wrapper.set_normal(slot8, ray_wrapper)

		slot12 = 1

		ray_wrapper.set_normal_color(slot8, ray_wrapper, 0, 0)
	else
		slot12 = 0

		ray_wrapper.set_color(slot8, ray_wrapper, 0, 1)
	end

	slot9 = param_list[1]

	if type(slot8) == "string" then
		local trajectory_dir, trajectory_len, trajectory_gravity, trajectory_wind, trajectory_drag = nil
		local i = 1

		while i < #param_list do
			local param = param_list[i]

			if param == "ray" then
				slot19 = ray_wrapper
				slot17 = ray_wrapper.from(slot18) or param_list[i + 1]

				ray_wrapper.set_from(slot15, ray_wrapper)

				slot19 = ray_wrapper
				slot17 = ray_wrapper.to(slot18) or param_list[i + 2]

				ray_wrapper.set_to(slot15, ray_wrapper)

				i = i + 2
			elseif param == "sphere_cast_radius" then
				slot17 = param_list[i + 1]

				ray_wrapper.set_radius(slot15, ray_wrapper)

				i = i + 1
			elseif param == "slot_mask" then
				i = i + 1

				while i < #param_list and type(slot15) ~= "string" do
					i = i + 1
				end
			elseif param == "bundle" then
				slot17 = param_list[i + 1]

				ray_wrapper.set_bundle(slot15, ray_wrapper)

				i = i + 1
			elseif param == "ignore_body" or param == "ignore_unit" or param == "target_body" or param == "target_unit" or param == "passed" or param == "ray_type" then
				i = i + 1
			elseif param == "trajectory" then
				local from = param_list[i + 1]
				slot18 = from

				ray_wrapper.set_from(slot16, ray_wrapper)

				slot17 = ray_wrapper

				if not ray_wrapper.to(slot16) then
					slot17 = param_list[i + 2]
					trajectory_dir = param_list[i + 2].normalized(slot16)
					trajectory_len = param_list[i + 3]
				end

				i = i + 3
			elseif param == "gravity" then
				trajectory_gravity = param_list[i + 1]
				i = i + 1
			elseif param == "wind" then
				trajectory_wind = param_list[i + 1]
				i = i + 1
			elseif param == "drag" then
				trajectory_drag = param_list[i + 1]
				i = i + 1
			elseif param == "points" then
				point_list = param_list[i + 1]
				i = i + 1
			else
				while i < #param_list and type(slot15) ~= "string" do
					i = i + 1
				end
			end

			i = i + 1
		end

		if point_list then
			local to_index = nil

			if ray and ray.hit_segment then
				to_index = ray.hit_segment
			else
				to_index = #point_list
			end

			for i = 2, to_index, 1 do
				slot21 = ray_wrapper
				ray_wrapper = DebugRaycast.new(slot19, DebugRaycast)
				slot21 = point_list[i - 1]

				ray_wrapper.set_from(slot19, ray_wrapper)

				slot21 = point_list[i]

				ray_wrapper.set_to(slot19, ray_wrapper)

				if i < to_index then
					slot21 = ray_wrapper

					table.insert(slot19, self._ray_list)
				end
			end
		elseif trajectory_dir then
			if not trajectory_gravity then
				slot17 = -982
				trajectory_gravity = Vector3(slot14, 0, 0)
			end

			slot15 = ray_wrapper
			local to = ray_wrapper.from(slot14) + trajectory_dir * trajectory_len + trajectory_gravity * trajectory_len

			if trajectory_wind then
				to = to + trajectory_wind * (trajectory_drag or 1) * trajectory_len
			end

			slot17 = to

			ray_wrapper.set_to(slot15, ray_wrapper)
		end
	else
		slot12 = ray_wrapper
		slot10 = ray_wrapper.from(slot11) or param_list[1]

		ray_wrapper.set_from(slot8, ray_wrapper)

		slot12 = ray_wrapper
		slot10 = ray_wrapper.to(slot11) or param_list[2]

		ray_wrapper.set_to(slot8, ray_wrapper)
	end

	slot10 = ray_wrapper

	table.insert(slot8, self._ray_list)

	return ray
end
HijackDebug.reloaded = function (self)
	slot4 = false

	self.set_ray_enabled(slot2, self)

	return 
end
HijackDebug.hijack_statemachine = function (self, unit, unit_state_func, machine_state_func, redirect_func)
	slot7 = unit
	local machine = unit.anim_state_machine(slot6)

	if machine then
		slot8 = unit
		local unit_key = unit.key(slot7)
		self._hijacked_statemachine_map = self._hijacked_statemachine_map or {}

		if not self._hijacked_statemachine_map[unit_key] then
			slot9 = self
			slot7 = self.hijack_func
			slot10 = unit
			slot11 = "play_state"

			if not unit_state_func then
				slot16 = "play_unit_state"
				slot12 = callback(slot13, self, self)
			end

			slot7(slot8, slot9, slot10, slot11)

			slot9 = self
			slot7 = self.hijack_func
			slot10 = unit
			slot11 = "play_redirect"

			if not redirect_func then
				slot16 = "play_redirect"
				slot12 = callback(slot13, self, self)
			end

			slot7(slot8, slot9, slot10, slot11)

			slot9 = self
			slot7 = self.hijack_func
			slot10 = machine
			slot11 = "play"

			if not machine_state_func then
				slot16 = "play_machine_state"
				slot12 = callback(slot13, self, self)
			end

			slot7(slot8, slot9, slot10, slot11)

			slot9 = self
			slot7 = self.hijack_func
			slot10 = machine
			slot11 = "play_redirect"

			if not redirect_func then
				slot16 = "play_redirect"
				slot12 = callback(slot13, self, self)
			end

			slot7(slot8, slot9, slot10, slot11)

			self._hijacked_statemachine_map[unit_key] = unit
			slot10 = "Hijacked play and play_redirect."

			cat_print(slot8, "debug")
		else
			slot11 = "play"

			self.unhijack_func(slot8, self, machine)

			slot11 = "play_redirect"

			self.unhijack_func(slot8, self, machine)

			slot11 = "play_state"

			self.unhijack_func(slot8, self, unit)

			slot11 = "play_redirect"

			self.unhijack_func(slot8, self, unit)

			self._hijacked_statemachine_map[unit_key] = nil
			slot10 = "Unhijacked play and play_redirect."

			cat_print(nil, "debug")
		end
	else
		slot12 = unit
		slot9 = "No state machine on unit \"" .. unit.name(slot11) .. "\"."

		cat_error(slot7, "debug")
	end

	return 
end
HijackDebug.hijack_func = function (self, obj, func_name, func, is_metatable)
	local meta = nil

	if is_metatable then
		meta = obj
	else
		slot8 = obj
		meta = getmetatable(slot7) or obj
	end

	slot9 = "hijacked_" .. func_name
	slot13 = func_name

	rawset(slot7, meta, rawget(slot11, meta))

	slot10 = func

	rawset(slot7, meta, func_name)

	return 
end
HijackDebug.unhijack_func = function (self, obj, func_name, is_metatable)
	local meta = nil

	if is_metatable then
		meta = obj
	else
		slot7 = obj
		meta = getmetatable(slot6) or obj
	end

	slot8 = func_name
	slot12 = "hijacked_" .. func_name

	rawset(slot6, meta, rawget(slot10, meta))

	slot9 = nil

	rawset(slot6, meta, "hijacked_" .. func_name)

	return 
end
HijackDebug.play_unit_state = function (self, unit, state)
	slot6 = state
	local result = unit.hijacked_play_state(slot4, unit)

	if 0 < #result then
		slot10 = state
		slot12 = result
		slot7 = "STATE \"" .. tostring(slot9) .. "\" --> \"" .. tostring(slot11) .. "\"."

		cat_debug(slot5, "debug")
	end

	return result
end
HijackDebug.play_machine_state = function (self, machine, state)
	slot6 = state
	local result = machine.hijacked_play(slot4, machine)

	if 0 < #result then
		slot10 = state
		slot12 = result
		slot7 = "STATE \"" .. tostring(slot9) .. "\" --> \"" .. tostring(slot11) .. "\"."

		cat_debug(slot5, "debug")
	end

	return result
end
HijackDebug.play_redirect = function (self, machine_or_unit, redirect)
	slot6 = redirect
	local result = machine_or_unit.hijacked_play_redirect(slot4, machine_or_unit)

	if 0 < #result then
		slot10 = redirect
		slot12 = result
		slot7 = "REDIRECT \"" .. tostring(slot9) .. "\" --> \"" .. tostring(slot11) .. "\"."

		cat_debug(slot5, "debug")
	end

	return result
end

if not SimpleDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

SimpleDebug = slot0
SimpleDebug.init = function (self)
	slot3 = self

	SimpleDebug.super.init(slot2)

	self._depricate_list = {}

	return 
end
SimpleDebug.add_depricate = function (self, dep_type, depricate_time, ...)
	local dep = {
		type = dep_type
	}
	slot6 = TimerManager
	slot6 = TimerManager.wall(slot5)
	dep.time = TimerManager.wall(slot5).time(slot5)
	dep.duration = depricate_time
	dep.arg = {
		...
	}
	slot7 = dep

	table.insert(slot5, self._depricate_list)

	return 
end
SimpleDebug.draw_depricate = function (self, dep, red, green, blue)
	if dep.type == "line" then
		slot12 = blue

		Application.draw_line(slot6, Application, dep.arg[1], dep.arg[2], red, green)
	elseif dep.type == "sphere" then
		slot12 = blue

		Application.draw_sphere(slot6, Application, dep.arg[1], dep.arg[2], red, green)
	end

	return 
end
SimpleDebug.draw_line = function (self, start_pos, end_pos, depricate_time)
	slot10 = end_pos

	self.add_depricate(slot5, self, "line", depricate_time, start_pos)

	return 
end
SimpleDebug.draw_sphere = function (self, pos, radie, depricate_time)
	slot10 = radie

	self.add_depricate(slot5, self, "sphere", depricate_time, pos)

	return 
end
SimpleDebug.update = function (self, time, rel_time)
	local remove_list = {}
	slot6 = self._depricate_list

	for index, dep in ipairs(slot5) do
		local elapsed_time = time - dep.time

		if dep.duration < elapsed_time then
			slot13 = index

			table.insert(slot11, remove_list)
		else
			local green = (dep.duration - elapsed_time) / dep.duration
			local red = 1 - green
			slot18 = 0

			self.draw_depricate(slot13, self, dep, red, green)
		end
	end

	slot6 = remove_list

	for i, index in ipairs(slot5) do
		slot12 = index

		table.remove(slot10, self._depricate_list)
	end

	return 
end
SimpleDebug.clear = function (self)
	slot3 = self

	SimpleDebug.super.clear(slot2)

	self._depricate_list = {}

	return 
end

if not PrintDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

PrintDebug = slot0
PrintDebug.xml_file = function (self, file, indent, indent_string)
	return 
end
PrintDebug.node = function (self, node, indent, indent_string)

	-- Decompilation error in this vicinity:
	indent = indent or 0
	indent_string = indent_string or "\t"
	slot8 = indent_string
	slot7 = indent
	slot10 = node
	local str = string.rep(slot5, tostring(slot7)) .. "<" .. tostring(node.name(slot9))
	slot9 = node

	for k, v in pairs(node.parameter_map(node.name)) do
		slot14 = k
		slot16 = v
		str = str .. " " .. tostring(slot13) .. "=\"" .. tostring(slot15) .. "\""
	end

	slot7 = node

	if 0 < node.num_children(slot6) then
		slot8 = str .. ">"

		cat_print(slot6, "debug")

		slot7 = node

		for child_node in node.children(slot6) do
			slot14 = indent_string

			self.node(slot10, self, child_node, indent + 1)
		end

		slot12 = indent_string
		slot11 = indent
		slot14 = node
		slot8 = string.rep(slot9, tostring(slot11)) .. "</" .. tostring(node.name(slot13)) .. ">"

		cat_print(slot6, "debug")
	else
		slot8 = str .. "/>"

		cat_print(slot6, "debug")
	end

	return 
end

if not ProfilerDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

ProfilerDebug = slot0
ProfilerDebug.init = function (self)
	slot3 = self

	ProfilerDebug.super.init(slot2)

	self._counter_list = {}
	self._counter_map = {}

	return 
end
ProfilerDebug.clear = function (self)
	slot3 = self

	ProfilerDebug.super.clear(slot2)

	slot3 = self._counter_map

	for _, counter in pairs(slot2) do
		slot9 = false

		counter.set_enabled(slot7, counter)
	end

	self._counter_list = {}
	self._counter_map = {}

	return 
end
ProfilerDebug.add_counter = function (self, counter_name, obj, func_name, color, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counter, override_class)
	local counter = self._counter_map[counter_name]

	if counter then
		slot18 = false

		self.remove_counter(slot14, self, counter, print_counter)
	end

	local index = #self._counter_list + 1
	slot27 = override_class
	counter = DebugProfilerCounter.new(slot15, DebugProfilerCounter, counter_name, index, obj, func_name, color, min_range, max_range, not disabled, not graph_disabled, not gui_disabled)
	self._counter_map[counter_name] = counter
	slot17 = counter

	table.insert(slot15, self._counter_list)

	if print_counter then
		slot21 = counter_name
		slot16 = "Add " .. index .. ": " .. tostring(slot20)

		cat_debug(slot15)
	end

	return 
end
ProfilerDebug.remove_index = function (self, index, print_counter, skip_color_update)
	local counter = self._counter_list[index]

	if counter then
		slot10 = skip_color_update

		self.remove_counter(slot6, self, counter, print_counter)
	end

	return 
end
ProfilerDebug.remove_name = function (self, counter_name, print_counter, skip_color_update)
	local counter = self._counter_map[counter_name]

	if counter then
		slot10 = skip_color_update

		self.remove_counter(slot6, self, counter, print_counter)
	end

	return 
end
ProfilerDebug.remove_counter = function (self, counter, print_counter, skip_color_update)
	if counter then
		local index = counter.index(slot5)
		slot8 = false

		counter.set_enabled(counter, counter)

		slot8 = counter
		self._counter_map[counter.name(counter)] = nil
		slot8 = index

		table.remove(counter.name(counter), self._counter_list)

		for i = index, #self._counter_list, 1 do
			slot12 = i

			self._counter_list[i].set_index(slot10, self._counter_list[i])
		end

		if not skip_color_update then
			slot7 = self

			self.update_colors(slot6)
		end

		if print_counter then
			slot14 = counter
			slot7 = "Remove " .. index .. ": " .. tostring(counter.name(slot13))

			cat_debug(slot6)
		end
	end

	return 
end
ProfilerDebug.update_colors = function (self)
	slot3 = self._counter_list

	for index, counter in ipairs(slot2) do
		slot9 = #self._counter_list
		local color_list = DebugManager.get_color_by_index(slot7, index)
		slot12 = color_list[3]
		local color = Color(index, 1, color_list[1], color_list[2])
		slot11 = color

		counter.set_color(1, counter)
	end

	return 
end
ProfilerDebug.set_unit_enabled = function (self, unit, enabled, function_name_list, ignore_map, include_only_map, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters, class_override)
	slot15 = unit

	if alive(slot14) and unit.type_name == "Unit" then
		function_name_list = function_name_list or {
			"update"
		}
		slot17 = unit

		for _, extension_name in ipairs(unit.extensions(slot16)) do
			slot20 = function_name_list

			for _, function_name in ipairs(slot19) do
				slot25 = unit
				slot29 = function_name
				local counter_name = unit.name(slot24) .. ":" .. extension_name .. ":" .. tostring(slot28) .. "()"
				slot29 = true

				self.remove_name(extension_name, self, counter_name, print_counters)

				if enabled then
					slot26 = unit
					local extension = unit[extension_name](slot25)

					if extension.update and (not ignore_map or not ignore_map[extension_name]) and (not include_only_map or include_only_map[extension_name]) then
						slot38 = not class_override

						self.add_counter(slot26, self, counter_name, extension, function_name, nil, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters)
					end
				end
			end
		end

		slot15 = self

		self.update_colors(slot14)
	end

	return 
end
ProfilerDebug.set_managers_enabled = function (self, enabled, ignore_map, include_only_map, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters)
	slot12 = managers

	for manager_name, manager in pairs(slot11) do
		local counter_name = "managers." .. manager_name .. ":update()"
		slot21 = true

		self.remove_name(":update()", self, counter_name, print_counters)

		if enabled then
			slot18 = manager

			if type(slot17) == "table" and manager.update and (not ignore_map or not ignore_map[manager_name]) and (not include_only_map or include_only_map[manager_name]) then
				slot29 = nil

				self.add_counter(slot17, self, counter_name, manager, "update", nil, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters)
			end
		end
	end

	slot12 = self

	self.update_colors(slot11)

	return 
end
ProfilerDebug.reloaded = function (self)
	slot3 = self._counter_list

	for _, counter in ipairs(slot2) do
		slot8 = counter

		counter.reload(slot7)
	end

	return 
end
ProfilerDebug.toggle_compare_find = function (self, slotmask, find_type, radius, length, count, bundle_count, func_name)
	local f = nil
	local list = {}
	local result = nil

	if func_name ~= "find_units" and func_name ~= "find_bodies" and func_name ~= "find_units_quick" then
		slot17 = func_name
		slot14 = "Invalid function: " .. tostring(slot16)

		cat_error(slot12, "debug")

		return 
	end

	slot13 = radius

	if not tonumber(slot12) then
		slot17 = radius
		slot14 = "Invalid radius: " .. tostring(slot16)

		cat_error(slot12, "debug")

		return 
	end

	slot13 = length

	if not tonumber(slot12) then
		slot17 = length
		slot14 = "Invalid length: " .. tostring(slot16)

		cat_error(slot12, "debug")

		return 
	end

	slot13 = count

	if not tonumber(slot12) then
		slot17 = count
		slot14 = "Invalid count: " .. tostring(slot16)

		cat_error(slot12, "debug")

		return 
	end

	slot13 = bundle_count

	if not tonumber(slot12) then
		slot17 = bundle_count
		slot14 = "Invalid bundle count: " .. tostring(slot16)

		cat_error(slot12, "debug")

		return 
	end

	local can_intersect = func_name ~= "find_units_quick"

	if find_type == "cone" or find_type == "cylinder" or find_type == "capsule" then
		function f(from, to)
			slot10 = slotmask
			result = World[func_name](func_name, World, "force_slot", find_type, from, to, radius)

			return 
		end

		slot15 = {
			func = f,
			counter = "find_" .. find_type
		}

		table.insert(slot13, list)

		function f(from, to)
			slot10 = slotmask
			result = World[func_name](func_name, World, "force_physics", find_type, from, to, radius)

			return 
		end

		slot15 = {
			func = f,
			counter = "find_" .. find_type .. "_physics"
		}

		table.insert(slot13, list)

		if can_intersect then
			function f(from, to)
				slot11 = slotmask
				result = World[func_name](func_name, World, "intersect", "force_slot", find_type, from, to, radius)

				return 
			end

			slot15 = {
				func = f,
				counter = "find_" .. find_type .. "_intersect"
			}

			table.insert(slot13, list)

			function f(from, to)
				slot11 = slotmask
				result = World[func_name](func_name, World, "intersect", "force_physics", find_type, from, to, radius)

				return 
			end

			slot15 = {
				func = f,
				counter = "find_" .. find_type .. "_intersect_physics"
			}

			table.insert(slot13, list)
		end
	elseif find_type == "sphere" then
		function f(from, to)
			slot9 = slotmask
			result = World[func_name](func_name, World, "force_slot", find_type, from, radius)

			return 
		end

		slot15 = {
			func = f,
			counter = "find_" .. find_type
		}

		table.insert(slot13, list)

		function f(from, to)
			slot9 = slotmask
			result = World[func_name](func_name, World, "force_physics", find_type, from, radius)

			return 
		end

		slot15 = {
			func = f,
			counter = "find_" .. find_type .. "_physics"
		}

		table.insert(slot13, list)

		if can_intersect then
			function f(from, to)
				slot10 = slotmask
				result = World[func_name](func_name, World, "intersect", "force_slot", find_type, from, radius)

				return 
			end

			slot15 = {
				func = f,
				counter = "find_" .. find_type .. "_intersect"
			}

			table.insert(slot13, list)

			function f(from, to)
				slot10 = slotmask
				result = World[func_name](func_name, World, "intersect", "force_physics", find_type, from, radius)

				return 
			end

			slot15 = {
				func = f,
				counter = "find_" .. find_type .. "_intersect_physics"
			}

			table.insert(slot13, list)
		end
	else
		slot15 = "Invalid type: " .. find_type

		cat_error(slot13, "debug")

		return 
	end

	slot15 = "stats counters"

	Application.console_command(slot13, Application)

	if Global.spherecast_cost_counter_list then
		slot14 = Global.spherecast_cost_counter_list

		for index, counter in ipairs(slot13) do
			slot20 = "profiler remove " .. counter

			Application.console_command(slot18, Application)

			slot20 = "graph hide " .. counter

			Application.console_command(slot18, Application)

			slot21 = nil

			managers.debug.gui.set(slot18, managers.debug.gui, index)
		end

		slot16 = nil

		managers.debug.func.set(slot13, managers.debug.func, 1)

		Global.spherecast_cost_counter_list = nil

		return 
	end

	function f(from, to)
		slot13 = slotmask
		result = World.raycast(slot3, World, "ray", from, to, "sphere_cast_radius", radius, "bundle", bundle_count, "slot_mask")

		return 
	end

	slot15 = {
		counter = "bundlecast",
		func = f
	}

	table.insert(slot13, list)

	function f(from, to)
		slot11 = slotmask
		result = World.raycast(slot3, World, "ray", from, to, "sphere_cast_radius", radius, "slot_mask")

		return 
	end

	slot15 = {
		counter = "spherecast",
		func = f
	}

	table.insert(slot13, list)

	Global.spherecast_cost_counter_list = {}
	slot14 = list

	for index, data in ipairs() do
		slot20 = data.counter

		table.insert(slot18, Global.spherecast_cost_counter_list)
		Application.console_command(slot18, Application)

		slot22 = #list
		local r, g, b = unpack(DebugManager.get_color_by_index("profiler add " .. data.counter, index))
		slot22 = Application
		slot29 = b * 15

		Application.console_command(index, string.format(slot24, "graph counter %s color %X%X%X range 0 20", data.counter, r * 15, g * 15))

		slot24 = data.counter

		managers.debug.gui.set(index, managers.debug.gui, index)

		slot26 = b

		managers.debug.gui.set_color(index, managers.debug.gui, index, r, g)
	end

	slot15 = true

	managers.debug.set_enabled(slot13, managers.debug)

	slot15 = true

	managers.debug.set_enabled_paused(slot13, managers.debug)

	slot15 = true

	managers.debug.func.set_enabled(slot13, managers.debug.func)

	slot15 = true

	managers.debug.gui.set_enabled(slot13, managers.debug.gui)

	function slot16()
		local rand_list = {}

		for i = #list, 1, -1 do
			local rand_index = math.random(slot6)
			slot9 = list[rand_index]

			table.insert(#list, rand_list)

			slot9 = rand_index

			table.remove(#list, list)
		end

		list = rand_list

		if managers.viewport then
			slot3 = managers.viewport
			local camera = managers.viewport.get_current_camera(slot2)
		end

		if not camera then
			slot5 = "No camera available."

			cat_error(slot3, "debug")

			slot6 = nil

			managers.debug.func.set(slot3, managers.debug.func, 1)

			return 
		end

		local rot = camera.rotation(slot3)
		local dir = rot.y(camera)
		slot6 = camera
		local from = camera.position(rot) + dir * 1000
		local to = from + dir * length

		if find_type == "cone" then
			slot14 = 1

			Application.draw_cone(slot7, Application, from, to, radius, 1, 1)
		elseif find_type == "sphere" then
			slot13 = 1

			Application.draw_sphere(slot7, Application, from, radius, 1, 1)
		else
			slot14 = 1

			Application.draw_cylinder(slot7, Application, from, to, radius, 1, 1)
		end

		local id = nil
		slot9 = rand_list

		for _, data in ipairs(slot8) do
			slot15 = data.counter
			id = Profiler.start(slot13, Profiler)

			for i = 1, count, 1 do
				slot19 = to

				data.func(slot17, from)
			end

			slot15 = id

			Profiler.stop(slot13, Profiler)
		end

		return 
	end

	managers.debug.func.set(slot13, managers.debug.func, 1)

	slot20 = slotmask
	slot15 = "Unit count: " .. #World.find_units_quick(slot17, World, "all")

	cat_debug(slot13, "debug")

	return 
end

if not MacroDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

MacroDebug = slot0
MacroDebug.DEFAULT_LINE_DURATION = 2
MacroDebug.init = function (self)
	slot3 = self

	MacroDebug.super.init(slot2)

	self._default_push_velocity_dir = math.UP
	self._default_push_velocity_length = 1000
	self._default_push_mass = 100000
	self._default_spawn_cam_offset = 1000
	self._default_multi_spawn_unit_offset = 300
	self._default_multi_spawn_unit_count = 10
	self._verbose_unit_map = {}
	self._profile_unit_map = {}

	return 
end
MacroDebug.get_ray = function (self, skip_last_unit_assign)

	-- Decompilation error in this vicinity:
	slot4 = managers.viewport
	local cam = managers.viewport.get_current_camera(slot3)
	local to = from + slot4 * 100000
	slot12 = "body editor phantom bullet"
	local ray = World.raycast(slot6, World, "ray", from, to, "ray_type")

	if ray then
		slot9 = ray

		self.set_last_ray(slot7, self)

		if not skip_last_unit_assign then
			slot9 = ray.unit

			self.set_last_unit(slot7, self)
		end

		slot14 = 10

		managers.debug.pos.add(slot7, managers.debug.pos, ray.position, "ray", nil, nil, nil)

		slot9 = true

		managers.debug.set_enabled(slot7, managers.debug)

		slot9 = true

		managers.debug.set_enabled_paused(slot7, managers.debug)

		slot9 = true

		managers.debug.pos.set_enabled(slot7, managers.debug.pos)
	end

	return ray
end
MacroDebug.set_last_ray = function (self, ray)
	self._last_ray = ray
	slot6 = ray

	rawset(slot3, _G, "r")

	return 
end
MacroDebug.get_last_ray = function (self)
	return self._last_ray
end
MacroDebug.set_last_unit = function (self, unit)

	-- Decompilation error in this vicinity:
	self._last_unit = unit
	slot4 = unit
end
MacroDebug.get_last_unit = function (self)
	return self._last_unit
end
MacroDebug.ray = function (self)
	slot3 = self
	local ray = self.get_ray(slot2)

	if ray then
		slot5 = ray.unit

		self.print_unit_info(slot3, self)

		slot10 = ray.body
		slot10 = ray.body.name(slot9)
		slot10 = ray.position
		slot13 = ray.distance
		slot5 = "Body: " .. tostring(ray.body.name(slot9).t(slot9)) .. ", Pos: " .. tostring(slot9) .. ", Len: " .. string.format(slot11, "%.3f")

		cat_print(slot3, "debug")
	else
		slot5 = "No unit found."

		cat_error(slot3, "debug")
	end

	return 
end
MacroDebug.print_unit_info = function (self, unit)
	slot4 = unit

	if alive(slot3) then
		slot5 = unit
		local unit_file, object_file, sequence_file, anim_machine = self.get_unit_files(slot3, self)
		slot11 = unit
		slot11 = unit.name(slot10)
		slot13 = unit
		slot15 = unit
		slot15 = unit.author(slot14)
		local unit_string = "Name: " .. tostring(unit.name(slot10).t(slot10)) .. ", Slot:" .. tostring(unit.slot(slot12)) .. ", Author: " .. tostring(unit.author(slot14).t(slot14))

		if 0 < #anim_machine then
			slot11 = anim_machine
			unit_string = unit_string .. ", Anim: " .. tostring(slot10)
		end

		slot10 = unit_string

		cat_print(slot8, "debug")

		slot13 = unit_file
		slot10 = "Unit:     " .. tostring(slot12)

		cat_print(slot8, "debug")

		slot13 = object_file
		slot10 = "Object:   " .. tostring(slot12)

		cat_print(slot8, "debug")

		if sequence_file then
			slot10 = "Sequence: " .. sequence_file

			cat_print(slot8, "debug")
		end
	elseif unit then
		slot5 = "Unit is dead."

		cat_error(slot3, "debug")
	else
		slot5 = "Unit is nil."

		cat_error(slot3, "debug")
	end

	return 
end
MacroDebug.get_unit_files = function (self, unit)
	local object_file, unit_file = nil
	slot9 = unit
	slot8 = ""
	local unit_data = PackageManager.unit_data(slot5, PackageManager, unit.name(slot8).id(slot8))
	slot7 = Application
	local base = Application.base_path(PackageManager) .. "..\\..\\assets\\"
	slot10 = unit
	slot10 = unit.name(unit.name(slot8))
	local unit_name = tostring(unit.name(unit.name(slot8)).t(unit.name(slot8)))
	local unit_file = base .. unit_name .. ".unit"
	local object_file = base .. unit_name .. ".object"
	slot12 = unit_name
	local relative_sequence_file = managers.sequence.get_sequence_file(".object", managers.sequence)

	if relative_sequence_file then
		slot15 = relative_sequence_file
		local sequence_file = base .. tostring(relative_sequence_file.t(slot14)) .. "." .. CoreSequenceManager.SequenceManager.SEQUENCE_FILE_EXTENSION
	end

	slot14 = unit_file
	slot11 = self.get_cleaned_path(slot12, self)
	slot15 = object_file
	slot12 = self.get_cleaned_path(self, self)
	slot16 = sequence_file
	slot13 = self.get_cleaned_path(self, self)
	slot14 = tostring
	slot18 = unit_data

	if unit_data.anim(slot17) then
		slot18 = unit_data
		slot18 = unit_data.anim(slot17)
		slot16 = unit_data.anim(slot17).t(slot17)
	end

	return slot11, slot12, slot13, slot14(slot15)
end
MacroDebug.get_cleaned_path = function (self, path)
	if path then
		slot6 = path
		slot6 = "%1/%2"
		local clean_path = string.gsub(slot3, tostring(slot5), "(.-)[/\\]+(.-)")
		local hit_count = nil

		repeat
			slot8 = ""
			clean_path, hit_count = string.gsub(slot5, clean_path, "/[^/:]+/%.%.")
		until hit_count == 0

		return clean_path
	else
		return nil
	end

	return 
end
MacroDebug.ray_push = function (self, velocity_dir, velocity_length, mass)
	slot6 = self
	local ray = self.get_ray(slot5)

	if ray then
		slot11 = mass

		self.push(slot6, self, ray.unit, velocity_dir or ray.ray, velocity_length)

		slot13 = ray.unit
		slot13 = ray.unit.name(slot12)
		slot15 = ray.body
		slot15 = ray.body.name(slot14)
		slot8 = "Unit: " .. tostring(ray.unit.name(slot12).t(slot12)) .. ", Body: " .. tostring(ray.body.name(slot14).t(slot14))

		cat_print(slot6, "debug")
	else
		slot8 = "No unit found."

		cat_error(slot6, "debug")
	end

	return 
end
MacroDebug.push = function (self, unit, velocity_dir, velocity_length, mass)
	velocity_dir = velocity_dir or self._default_push_velocity_dir
	velocity_length = velocity_length or self._default_push_velocity_length
	local effect_name = Idstring(slot6)
	slot10 = "physic_effect"

	CoreEngineAccess._editor_load("core/physic_effects/debugmanager_push", Idstring(effect_name))

	slot12 = mass or self._default_push_mass

	World.play_physic_effect(slot7, World, effect_name, unit, velocity_dir * velocity_length)

	return 
end
MacroDebug.ray_gravitate = function (self, multiplier)
	slot4 = self
	local ray = self.get_ray(slot3)

	if ray then
		slot7 = multiplier

		self.gravitate(slot4, self, ray.unit)

		slot11 = ray.unit
		slot11 = ray.unit.name(slot10)
		slot13 = ray.body
		slot13 = ray.body.name(slot12)
		slot6 = "Unit: " .. tostring(ray.unit.name(slot10).t(slot10)) .. ", Body: " .. tostring(ray.body.name(slot12).t(slot12))

		cat_print(slot4, "debug")
	else
		slot6 = "No unit found."

		cat_error(slot4, "debug")
	end

	return 
end
MacroDebug.gravitate = function (self, unit, multiplier)
	local effect_name = Idstring(slot4)
	slot8 = "physic_effect"

	CoreEngineAccess._editor_load("core/physic_effects/debugmanager_gravitate", Idstring(effect_name))

	slot11 = World
	slot9 = -World.gravity(slot10) * (multiplier or 1)

	World.play_physic_effect(slot5, World, effect_name, unit)

	return 
end
MacroDebug.stop_gravitate = function (self)
	local effect_name_str = "core/physic_effects/debugmanager_gravitate"
	local effect_name = Idstring(slot3)
	slot7 = "physic_effect"
	slot6 = effect_name

	CoreEngineAccess._editor_load(effect_name_str, Idstring(slot6))

	slot6 = effect_name_str

	World.stop_physic_effect(effect_name_str, World)

	return 
end
MacroDebug.ray_hover = function (self, multiplier)
	slot4 = self
	local ray = self.get_ray(slot3)

	if ray then
		slot7 = multiplier

		self.hover(slot4, self, ray.unit)

		slot11 = ray.unit
		slot11 = ray.unit.name(slot10)
		slot13 = ray.body
		slot13 = ray.body.name(slot12)
		slot6 = "Unit: " .. tostring(ray.unit.name(slot10).t(slot10)) .. ", Body: " .. tostring(ray.body.name(slot12).t(slot12))

		cat_print(slot4, "debug")
	else
		slot6 = "No unit found."

		cat_error(slot4, "debug")
	end

	return 
end
MacroDebug.hover = function (self, unit, multiplier)
	local effect_name = Idstring(slot4)
	slot8 = "physic_effect"

	CoreEngineAccess._editor_load("core/physic_effects/debugmanager_hover", Idstring(effect_name))

	slot11 = World
	slot9 = -World.gravity(slot10) * (multiplier or 1)

	World.play_physic_effect(slot5, World, effect_name, unit)

	return 
end
MacroDebug.stop_hover = function (self)
	local effect_name_str = "core/physic_effects/debugmanager_hover"
	local effect_name = Idstring(slot3)
	slot7 = "physic_effect"
	slot6 = effect_name

	CoreEngineAccess._editor_load(effect_name_str, Idstring(slot6))

	slot6 = effect_name_str

	World.stop_physic_effect(effect_name_str, World)

	return 
end
MacroDebug.effect = function (self, effect)

	-- Decompilation error in this vicinity:
	local cam = managers.viewport.get_current_camera(slot3)
	slot5 = World
	local effect_manager = World.effect_manager(managers.viewport)
	slot6 = effect_manager
	slot4 = effect_manager.spawn
	slot7 = {
		effect = effect.id(slot9)
	}
	slot10 = effect
end
MacroDebug.ray_run_sequence = function (self, sequence, damage_type, source_unit, dest_body, normal, position, direction, damage, velocity, params)
	slot13 = self
	local ray = self.get_ray(slot12)

	if ray then
		slot20 = ray.unit
		slot20 = ray.unit.name(slot19)
		slot22 = ray.body
		slot22 = ray.body.name(slot21)
		slot15 = "Unit: " .. tostring(ray.unit.name(slot19).t(slot19)) .. ", Body: " .. tostring(ray.body.name(slot21).t(slot21))

		cat_print(slot13, "debug")

		slot14 = ray.unit
		local damage_ext = ray.unit.damage(slot13)

		if damage_ext then
			if damage_ext.run_sequence then
				slot25 = params

				damage_ext.run_sequence(slot14, damage_ext, sequence, damage_type or "bullet", source_unit or ray.unit, dest_body or ray.body, normal or ray.normal, position or ray.position, direction or ray.ray, damage or 0, velocity or ray.ray * 1000)
			else
				slot16 = "Damage extension lacks run_sequence-function."

				cat_error(slot14, "debug")
			end
		else
			slot16 = "No damage extension."

			cat_error(slot14, "debug")
		end
	else
		slot15 = "No unit found."

		cat_error(slot13, "debug")
	end

	return 
end
MacroDebug.ray_select_unit = function (self)
	slot3 = self
	local ray = self.get_ray(slot2)

	if ray then
		slot10 = ray.unit
		slot10 = ray.unit.name(slot9)
		slot12 = ray.body
		slot12 = ray.body.name(slot11)
		slot5 = "Unit: " .. tostring(ray.unit.name(slot9).t(slot9)) .. ", Body: " .. tostring(ray.body.name(slot11).t(slot11))

		cat_print(slot3, "debug")

		slot5 = ray.unit

		self.select_unit(slot3, self)
	else
		slot5 = "No unit found."

		cat_error(slot3, "debug")
	end

	return 
end
MacroDebug.select_unit = function (self, unit)
	local selected_unit = World.selected_unit(slot3)
	slot6 = unit or self._last_unit

	self.set_last_unit(World, self)

	slot5 = self._last_unit

	if alive(slot4) then
		slot5 = selected_unit
	else
		slot6 = self._last_unit

		World.select_unit(slot4, World)
	end

	return 
end
MacroDebug.anim_verbose = function (self, unit)
	local selected_unit = World.selected_unit(slot3)
	slot6 = unit or self._last_unit or selected_unit

	self.set_last_unit(World, self)

	slot5 = self._last_unit

	if alive(slot4) then
		slot6 = self._last_unit

		World.select_unit(slot4, World)

		slot6 = self._last_unit

		if self._verbose_unit_map[self._last_unit.key(World)] then
			slot6 = self._last_unit
			self._verbose_unit_map[self._last_unit.key(slot5)] = nil
			slot6 = "animation verbose off"

			Application.console_command(self._last_unit.key(slot5), Application)
		else
			slot6 = self._last_unit
			slot4 = self._last_unit.key(slot5)
			self._verbose_unit_map[slot4] = true
			slot6 = "animation modifiers"

			Application.console_command(slot4, Application)

			slot6 = "animation playing"

			Application.console_command(slot4, Application)

			slot6 = "animation verbose"

			Application.console_command(slot4, Application)
		end
	end

	return 
end
MacroDebug.spawn = function (self, unit_name, pos, rot)
	unit_name = unit_name or self._last_unit_name
	slot8 = unit_name

	if DB.has(slot5, DB, "unit") then
		slot6 = managers.viewport
		local cam = managers.viewport.get_current_camera(slot5)
	else
		slot12 = unit_name
		slot7 = "Tried to spawn non-existing unit \"" .. tostring(unit_name.t(slot11)) .. "\"."

		cat_print(slot5, "debug")
	end

	return 
end
MacroDebug.multi_spawn = function (self, unit_name, unit_offset, count_x, count_y, count_z, pos, rot)

	-- Decompilation error in this vicinity:
	slot10 = managers.viewport
	local cam = managers.viewport.get_current_camera(slot9)
	unit_offset = unit_offset or self._default_multi_spawn_unit_offset
	count_x = (count_x or self._default_multi_spawn_unit_count) - 1
	count_y = (count_y or 1) - 1
	count_z = (count_z or 1) - 1

	for z = 0, count_z, 1 do
		slot17 = cam_rot
		local z_offset = cam_rot.y(slot16) * (count_z / 2 - z) * unit_offset

		for y = 0, count_y, 1 do
			slot22 = cam_rot
			local yz_offset = z_offset + cam_rot.z(slot21) * (count_y / 2 - y) * unit_offset

			for x = 0, count_x, 1 do
				local offset = yz_offset + cam_rot.x(slot26) * (count_x / 2 - x) * unit_offset
				slot31 = rot

				self.spawn(cam_rot, self, unit_name, pos + offset)
			end
		end
	end

	return 
end
MacroDebug.ray_profile_unit = function (self, function_name_list, ignore_map, include_only_map, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters, instance_override)
	slot13 = self
	local ray = self.get_ray(slot12)

	if ray then
		slot18 = ray.unit
		slot20 = ray.body
		slot15 = "Unit: " .. ray.unit.name(slot17) .. ", Body: " .. ray.body.name(slot19)

		cat_print(slot13, "debug")

		slot15 = ray.unit

		self.profile_unit(slot13, self)
	else
		slot15 = "No unit found."

		cat_error(slot13, "debug")
	end

	return 
end
MacroDebug.profile_unit = function (self, unit, function_name_list, ignore_map, include_only_map, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters, instance_override)
	slot14 = unit

	if alive(slot13) then
		slot15 = unit

		self.set_last_unit(slot13, self)
	end

	slot14 = self._last_unit

	if alive(slot13) then
		slot15 = self._last_unit
		local enabled = not self._profile_unit_map[self._last_unit.key(slot14)]
		slot27 = instance_override

		managers.debug.profiler.set_unit_enabled(slot14, managers.debug.profiler, self._last_unit, enabled, function_name_list, ignore_map, include_only_map, min_range, max_range, disabled, graph_disabled, gui_disabled, print_counters)

		slot16 = self._last_unit
		self._profile_unit_map[self._last_unit.key(managers.debug.profiler)] = enabled
	end

	return 
end
MacroDebug.unit_goto = function (self, add_to_path, unit, pos)
	if not unit then
		slot6 = self
		unit = self.get_last_unit(slot5)
	end

	slot6 = unit

	if alive(slot5) then
		slot6 = unit
	else
		slot10 = unit
		slot7 = "Goto-action not available on unit \"" .. tostring(slot9) .. "\"."

		cat_error(slot5, "debug")
	end

	return 
end
MacroDebug.fps = function (self, graph)
	if not self._check_fps and not self._check_fps_pause_time then
		slot5 = true

		managers.debug.set_enabled(slot3, managers.debug)

		slot5 = true

		managers.debug.set_enabled_paused(slot3, managers.debug)

		slot5 = true

		managers.debug.gui.set_enabled(slot3, managers.debug.gui)

		slot5 = true

		self.set_enabled(slot3, self)

		self._check_fps = true
		self._check_fps_graph = graph
		self._check_fps_time = nil
		self._check_fps_count = nil
		self._check_fps_min = nil
		self._check_fps_max = nil
		self._check_fps_old = nil
		slot8 = 1

		managers.debug.gui.set_color(slot3, managers.debug.gui, 1, 1, 1)

		slot8 = 1

		managers.debug.gui.set_color(slot3, managers.debug.gui, 2, 0, 0)

		slot8 = 0

		managers.debug.gui.set_color(slot3, managers.debug.gui, 3, 0, 1)

		slot8 = 0

		managers.debug.gui.set_color(slot3, managers.debug.gui, 4, 1, 0)

		if graph then
			slot5 = true

			managers.debug.graph.set_enabled(slot3, managers.debug.graph)

			slot6 = 50

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, 1)

			slot6 = 50

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, 2)

			slot6 = 50

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, 3)

			slot6 = 50

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, 4)
		end
	else
		if self._check_fps_graph then
			slot5 = 1

			managers.debug.graph.clear(slot3, managers.debug.graph)

			slot5 = 2

			managers.debug.graph.clear(slot3, managers.debug.graph)

			slot5 = 3

			managers.debug.graph.clear(slot3, managers.debug.graph)

			slot5 = 4

			managers.debug.graph.clear(slot3, managers.debug.graph)

			slot5 = 1
			slot9 = nil

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, managers.debug.pos.get_max_count(slot7, managers.debug.pos))

			slot5 = 2
			slot9 = nil

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, managers.debug.pos.get_max_count(slot7, managers.debug.pos))

			slot5 = 3
			slot9 = nil

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, managers.debug.pos.get_max_count(slot7, managers.debug.pos))

			slot5 = 4
			slot9 = nil

			managers.debug.graph.set_max_count(slot3, managers.debug.graph, managers.debug.pos.get_max_count(slot7, managers.debug.pos))
		end

		self._check_fps_pause_time = nil
		self._check_fps = nil
		self._check_fps_graph = nil
		self._check_fps_time = nil
		self._check_fps_count = nil
		self._check_fps_min = nil
		self._check_fps_max = nil
		self._check_fps_old = nil
		slot6 = nil

		managers.debug.gui.set(slot3, managers.debug.gui, 1)

		slot8 = 0

		managers.debug.gui.set_color(slot3, managers.debug.gui, 1, 1, 0)

		slot6 = nil

		managers.debug.gui.set(slot3, managers.debug.gui, 2)

		slot8 = 0

		managers.debug.gui.set_color(slot3, managers.debug.gui, 2, 1, 0)

		slot6 = nil

		managers.debug.gui.set(slot3, managers.debug.gui, 3)

		slot8 = 0

		managers.debug.gui.set_color(slot3, managers.debug.gui, 3, 1, 0)

		slot6 = nil

		managers.debug.gui.set(slot3, managers.debug.gui, 4)

		slot8 = 0

		managers.debug.gui.set_color(slot3, managers.debug.gui, 4, 1, 0)
	end

	return 
end
MacroDebug.is_fps_enabled = function (self)
	return self._check_fps or self._check_fps_pause_time
end
MacroDebug.set_fps_paused = function (self, paused)
	if not paused ~= not self._check_fps_pause_time then
		slot4 = self

		self.toggle_fps_paused(slot3)
	end

	return 
end
MacroDebug.toggle_fps_paused = function (self)
	slot3 = TimerManager
	slot3 = TimerManager.wall(slot2)
	local wall_time = TimerManager.wall(slot2).time(slot2)

	if self._check_fps_pause_time then
		if self._check_fps_time then
			self._check_fps_time = self._check_fps_time + wall_time - self._check_fps_pause_time
		end

		self._check_fps = true
		self._check_fps_pause_time = nil
	elseif self._check_fps then
		self._check_fps = nil
		self._check_fps_pause_time = wall_time
	end

	return 
end
MacroDebug.test_spawn_all = function (self, layer_name, sub_type)
	if not managers.editor then
		slot6 = "Need to run this in the editor."

		cat_error(slot4, "debug")
	elseif not layer_name then
		local allowed_layer_name_map = {
			Statics = true
		}
		slot6 = managers.editor._layers

		for next_layer_name, layer in pairs(slot5) do
			if allowed_layer_name_map[next_layer_name] then
				slot12 = sub_type

				layer.test_spawn(slot10, layer)
			end
		end
	else
		local layer = managers.editor._layers[layer_name]

		if not layer then
			slot10 = layer_name
			slot7 = "Layer name \"" .. tostring(slot9) .. "\" doesn't exists."

			cat_error(slot5, "debug")
		else
			slot7 = sub_type

			layer.test_spawn(slot5, layer)
		end
	end

	return 
end
MacroDebug.set_draw_unit_enabled = function (self, unit_name, is_enabled, draw_camera_line, draw_on_top, red, green, blue, disabled_color_scale)
	local unit_name_id = nil
	slot12 = unit_name

	if type(slot11) == "string" then
		slot12 = unit_name
		unit_name_id = Idstring(slot11)
	else
		unit_name_id = unit_name
	end

	slot12 = unit_name_id
	local unit_name_id_key = unit_name_id.key(slot11)

	if is_enabled then
		local unit_list = World.find_units_quick(slot12, World)
		local draw_unit_list = {}
		slot15 = unit_list

		for _, unit in ipairs("all") do
			slot20 = unit

			if unit.name(slot19) == unit_name_id then
				slot21 = unit

				table.insert(slot19, draw_unit_list)
			end
		end

		slot15 = draw_unit_list

		if not next(slot14) then
			slot16 = "No unit found."

			cat_error(slot14, "debug")

			return 
		end

		slot16 = true

		managers.debug.set_enabled(slot14, managers.debug)

		slot16 = true

		managers.debug.set_enabled_paused(slot14, managers.debug)

		slot16 = true

		self.set_enabled(slot14, self)

		disabled_color_scale = disabled_color_scale or 0.5
		slot20 = blue or 1
		local pen = Draw.pen(slot14, Draw, Color((draw_on_top and "no_z") or "normal", red or 1, green or 1))
		local disabled_red = (red or 1) * disabled_color_scale
		local disabled_green = (red or 1) * disabled_color_scale
		local disabled_blue = (red or 1) * disabled_color_scale
		slot24 = disabled_blue
		local disabled_pen = Draw.pen(red or 1, Draw, Color((draw_on_top and "no_z") or "normal", disabled_red, disabled_green))
		local data = {
			draw_unit_list = draw_unit_list,
			draw_camera_line = draw_camera_line,
			pen = pen,
			disabled_pen = disabled_pen
		}
		self._draw_unit_map = self._draw_unit_map or {}
		self._draw_unit_map[unit_name_id_key] = data
	elseif self._draw_unit_map and self._draw_unit_map[unit_name_id_key] then
		self._draw_unit_map[unit_name_id_key] = nil
		slot13 = self._draw_unit_map

		if not next(nil) then
			self._draw_unit_map = nil
		end
	end

	return 
end
MacroDebug.get_file_list_by_type = function (self, file_type)

	-- Decompilation error in this vicinity:
	slot5 = file_type
	local index = "indices/types/" .. tostring(slot4)
	slot7 = index

	return 
end
MacroDebug.get_asset_path = function (self)
	local is_assetslocation_arg = nil
	local relative_path = "../../assets/"
	slot7 = Application

	for _, v in ipairs(Application.argv(slot6)) do
		if v == "-assetslocation" then
			is_assetslocation_arg = true
		elseif is_assetslocation_arg then
			relative_path = v .. "/assets/"

			break
		end
	end

	slot5 = self
	slot11 = Application
	slot10 = true

	return self.get_cleaned_path(slot4, Application.nice_path(slot7, Application, Application.base_path(slot10) .. relative_path))
end
MacroDebug.check_dangerous_network_slot = function (self, slot_list)
	slot_list = slot_list or {
		0
	}
	local asset_path = self.get_asset_path(slot3)
	local unit_file_list = self.get_file_list_by_type(self, self)
	local found_unit_file_map = {}
	slot7 = unit_file_list

	for _, unit_file in ipairs("unit") do
		slot14 = unit_file
		local unit_node = DB.load_node(slot11, DB, "unit")
		local network_sync, object_file = nil
		slot18 = "slot"
		local original_slot = tonumber(unit_node.parameter(slot16, unit_node))
		slot16 = unit_node

		for child_node in unit_node.children(unit_node.parameter) do
			slot20 = child_node
			local child_node_name = child_node.name(slot19)

			if child_node_name == "network" then
				slot22 = "sync"
				local sync_type = child_node.parameter(slot20, child_node)

				if sync_type and sync_type ~= "none" then
					network_sync = sync_type
				else
					network_sync = false

					if false then
						network_sync = true
					end
				end
			elseif child_node_name == "object" then
				slot22 = "file"
				object_file = child_node.parameter(slot20, child_node)
			end
		end

		if network_sync and object_file then
			slot18 = object_file

			if DB.has(slot15, DB, "object") then
				local object_node = DB.load_node(slot15, DB, "object")
				local object_sequence_node = nil
				local unit_file_path = asset_path .. tostring(object_file) .. ".unit"
				local object_file_path = asset_path .. tostring(unit_file) .. ".object"

				local function check_slot_func(slot, sequence_file_path)
					slot4 = slot_list
					slot7 = slot

					if table.contains(slot3, tonumber(slot6)) then
						local sub_map = found_unit_file_map[slot]

						if not sub_map then
							sub_map = {}
							found_unit_file_map[slot] = sub_map
						end

						sub_map[unit_file] = {
							unit = unit_file_path,
							object = object_file_path,
							sequence = sequence_file_path,
							sync = network_sync,
							original_slot = original_slot,
							slot = slot
						}

						return true
					else
						return false
					end

					return 
				end

				slot22 = nil

				check_slot_func(object_file, original_slot)

				slot21 = object_node

				for child_node in object_node.children(object_file) do
					slot25 = child_node
					local child_node_name = child_node.name(slot24)

					if child_node_name == "sequence_manager" then
						object_sequence_node = child_node

						break
					end
				end

				if object_sequence_node then
					local sequence_file = object_sequence_node.parameter(slot20, object_sequence_node)
					slot23 = sequence_file
					local sequence_file_path = asset_path .. tostring("file") .. ".sequence_manager"

					if sequence_file then
						slot25 = sequence_file
					else
						slot27 = object_file
						slot24 = "Object " .. tostring(slot26) .. " has an invalid <sequence_manager file=\"...\"/> node."

						Application.error(slot22, Application)
					end
				end
			end
		end
	end

	slot7 = found_unit_file_map

	for _, list in pairs(slot6) do
		slot12 = list

		for unit_name, data in pairs(slot11) do

			-- Decompilation error in this vicinity:
			slot15 = cat_print
			slot17 = "debug"
			slot18 = "Slot: "
		end
	end

	return found_unit_file_map
end
MacroDebug.update = function (self, t, dt)
	if self._check_fps then
		slot5 = TimerManager
		slot5 = TimerManager.wall(slot4)
		local wall_time = TimerManager.wall(slot4).time(slot4)
		local fps, avg_fps = nil

		if not self._check_fps_time then
			self._check_fps_time = wall_time
			self._check_fps_count = 0
		else
			local duration = wall_time - self._check_fps_time
			self._check_fps_count = self._check_fps_count + 1

			if 0 < duration then
				avg_fps = self._check_fps_count / duration
			end

			if 0 < dt then
				fps = 1 / dt

				if (not self._check_fps_min or fps < self._check_fps_min) and self._check_fps_old and self._check_fps_old - fps < 5 then
					self._check_fps_min = fps
				end

				if (not self._check_fps_max or self._check_fps_max < fps) and self._check_fps_old and fps - self._check_fps_old < 5 then
					self._check_fps_max = fps
				end

				self._check_fps_old = fps
			end

			if fps then
				slot15 = fps
				slot11 = "FPS: " .. string.format(slot13, "%.1f")

				managers.debug.gui.set(slot8, managers.debug.gui, 1)
			else
				slot14 = fps
				slot11 = "FPS: " .. tostring(slot13)

				managers.debug.gui.set(slot8, managers.debug.gui, 1)
			end

			if avg_fps then
				slot15 = avg_fps
				slot11 = "AVG: " .. string.format(slot13, "%.1f")

				managers.debug.gui.set(slot8, managers.debug.gui, 2)
			else
				slot14 = avg_fps
				slot11 = "AVG: " .. tostring(slot13)

				managers.debug.gui.set(slot8, managers.debug.gui, 2)
			end

			if self._check_fps_max then
				slot15 = self._check_fps_max
				slot11 = "MAX: " .. string.format(slot13, "%.1f")

				managers.debug.gui.set(slot8, managers.debug.gui, 3)
			else
				slot14 = self._check_fps_max
				slot11 = "MAX: " .. tostring(slot13)

				managers.debug.gui.set(slot8, managers.debug.gui, 3)
			end

			if self._check_fps_min then
				slot15 = self._check_fps_min
				slot11 = "MIN: " .. string.format(slot13, "%.1f")

				managers.debug.gui.set(slot8, managers.debug.gui, 4)
			else
				slot14 = self._check_fps_min
				slot11 = "MIN: " .. tostring(slot13)

				managers.debug.gui.set(slot8, managers.debug.gui, 4)
			end

			if self._check_fps_graph and fps and avg_fps and self._check_fps_max and self._check_fps_min then
				slot14 = 1

				managers.debug.graph.add(slot8, managers.debug.graph, fps or 0, 1, 1, 1)

				slot14 = 1

				managers.debug.graph.add(slot8, managers.debug.graph, avg_fps or 0, 2, 0, 0)

				slot14 = 0

				managers.debug.graph.add(slot8, managers.debug.graph, self._check_fps_max or 0, 3, 0, 1)

				slot14 = 0

				managers.debug.graph.add(slot8, managers.debug.graph, self._check_fps_min or 0, 4, 1, 0)
			end
		end
	end

	if self._draw_unit_map then
		local remove_data_map = nil
		slot6 = self._draw_unit_map

		for unit_name_id_key, data in pairs(slot5) do
			local remove_unit_list = nil
			slot12 = data.draw_unit_list

			for i, unit in ipairs(slot11) do

				-- Decompilation error in this vicinity:
				slot17 = unit
				remove_unit_list = remove_unit_list or {}
				slot18 = i

				table.insert(slot16, remove_unit_list)

				slot17 = unit
				slot17 = unit
				local pen = (unit.visible(slot16) and data.pen) or data.disabled_pen
				slot19 = unit

				pen.draw(slot17, pen)

				slot18 = managers.viewport
				local cam = managers.viewport.get_current_camera(slot17)
				slot19 = cam
				local rot = cam.rotation(slot18) or Rotation()
				slot20 = pen
				slot18 = pen.line
				slot23 = unit
				slot21 = unit.position(slot22)
				slot25 = rot
				slot25 = rot
				slot22 = ((cam.position(slot23) or Vector3()) + rot.y(cam) * 10) - rot.z(cam) * 1

				slot18(slot19, slot20, slot21)
			end

			if remove_unit_list then
				slot12 = remove_unit_list

				for i, remove_index in ipairs(slot11) do
					slot18 = remove_index - i + 1

					table.remove(slot16, data.draw_unit_list)
				end

				slot12 = data.draw_unit_list

				if not next(slot11) then
					remove_data_map = remove_data_map or {}
					remove_data_map[unit_name_id_key] = true
				end
			end
		end

		if remove_data_map then
			slot6 = remove_data_map

			for remove_unit_name_id_key in pairs(slot5) do
				self._draw_unit_map[remove_unit_name_id_key] = nil
			end

			slot6 = self._draw_unit_map

			if not next(slot5) then
				self._draw_unit_map = nil
			end
		end
	end

	return 
end
MacroDebug.clear = function (self)
	slot3 = self

	MacroDebug.super.clear(slot2)

	if self._check_fps then
		slot3 = self

		self.fps(slot2)
	end

	self._draw_unit_map = nil

	return 
end
MacroDebug.toggle_endurance_damage_hook = function (self, skip_print, line_duration)
	line_duration = line_duration or self.DEFAULT_LINE_DURATION

	if self._endurance_damage_hook then
		slot8 = true

		managers.debug.hijack.unhijack_func(slot4, managers.debug.hijack, CoreSequenceManager.EnduranceElement, "activate")

		slot6 = "Disabled endurance damage hook."

		cat_debug(slot4, "debug")

		self._endurance_damage_hook = nil
	elseif not skip_print or (line_duration and 0 < line_duration) then
		slot13 = {
			skip_print = skip_print,
			line_duration = line_duration
		}
		slot9 = true

		managers.debug.hijack.hijack_func(slot4, managers.debug.hijack, CoreSequenceManager.EnduranceElement, "activate", callback(slot9, self, self, "_hijacked_endurance_activate"))

		slot9 = not skip_print
		slot11 = line_duration
		slot6 = "Enabled endurance damage hook. Output: " .. tostring(callback(slot9, self, self, "_hijacked_endurance_activate")) .. ", Line duration: " .. tostring(self)

		cat_debug(slot4, "debug")

		self._endurance_damage_hook = true
	else
		slot9 = not skip_print
		slot11 = line_duration
		slot6 = "Ignored endurance damage hook. Output: " .. tostring(slot8) .. ", Line duration: " .. tostring(slot10)

		cat_debug(slot4, "debug")
	end

	return 
end
MacroDebug._hijacked_endurance_activate = function (self, option_map, endurance, env)
	if not option_map.skip_print then
		slot6 = "debug"
		slot12 = env.dest_unit.name(slot13)
		slot15 = env.dest_body

		cat_print(slot5, string.format(slot8, "Damage: %d, Type: %s, Unit: %s, Body: %s", env.damage, env.damage_type, env.dest_body.name(env.dest_unit)))
	end

	if 0 < option_map.line_duration then
		slot9 = option_map.line_duration

		managers.debug.simple.draw_line(slot5, managers.debug.simple, env.pos, env.pos - env.dir * 200)
	end

	slot7 = env

	endurance.hijacked_activate(slot5, endurance)

	return 
end

if not MemoryDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

MemoryDebug = slot0
MemoryDebug.CALC_TYPE_FUNC_MAP = DebugManager.CALC_TYPE_FUNC_MAP or {
	table = "add_calc_table",
	boolean = "add_calc_boolean",
	function = "add_calc_function",
	string = "add_calc_string",
	userdata = "add_calc_userdata",
	number = "add_calc_number"
}
MemoryDebug.PRIMITIVE_VALUE_TYPE_MAP = DebugManager.PRIMITIVE_VALUE_TYPE_MAP or {
	boolean = true,
	string = true,
	number = true
}
MemoryDebug.extensions = function (self)
	slot4 = "all"
	local unit_list = World.find_units_quick(slot2, World)
	local extension_class_map = {}
	local extension_data_list = {}
	slot6 = unit_list

	for _, unit in ipairs(slot5) do
		local extension_list = unit.extensions(slot10)
		slot12 = extension_list

		for _, extension_name in ipairs(unit) do
			local extension_instance = unit[extension_name](slot16)
			local extension_class = getmetatable(unit)
			slot20 = _M
			local class_name_string = CoreDebug.class_name(extension_instance, extension_class)
			local data = extension_class_map[class_name_string]
			data = data or {
				count = 0,
				unit_count = {},
				unit_list = {}
			}
			data.count = data.count + 1
			slot22 = unit

			table.insert(slot20, data.unit_list)

			slot21 = unit
			local unit_name = unit.name(slot20)
			data.unit_count[unit_name] = (data.unit_count[unit_name] or 0) + 1
			extension_class_map[class_name_string] = data
		end
	end

	return extension_class_map
end
MemoryDebug.find_instance = function (self, find_value, is_meta_data, print_path, find_all, seen_map, map)
	if find_value ~= nil then
		local function func(path, key, value, populate_map, info_map, seen_map, func)
			slot19 = find_all

			return self.find_instance_callback(slot8, self, print_path, path, key, value, populate_map, info_map, seen_map, find_value, is_meta_data)
		end

		slot13 = map

		return self.traverse_instances(slot9, self, func, seen_map)
	else
		return nil, nil
	end

	return 
end
MemoryDebug.find_instance_callback = function (self, print_path, path, key, value, populate_map, info_map, seen_map, find_value, is_meta_data, find_all)
	local found = nil

	if is_meta_data then
		slot14 = value
	elseif value == find_value or key == find_value then
		found = true
	end

	if found then
		populate_map[key] = value

		if print_path then
			if path then
				path = path .. "."
			else
				path = ""
			end

			slot18 = key
			slot15 = path .. tostring(slot17)

			cat_print(slot13, "debug")
		end
	end

	return found, find_all
end
MemoryDebug.traverse_instances = function (self, func, seen_map, map)
	seen_map = seen_map or {}
	local populate_map = {}
	local info_map = {
		found_count = 0,
		count = 0,
		seen_count = 0
	}

	if map then
		slot15 = seen_map

		self.traverse_instances_recursively(slot7, self, nil, nil, map, func, populate_map, info_map)
	else
		local global_map = {}
		slot16 = seen_map

		self.traverse_instances_recursively(slot8, self, nil, "_G", _G, func, global_map, info_map)

		slot9 = global_map

		if next(slot8) ~= nil then
			populate_map._G = global_map
		end

		slot9 = World
		slot9 = World.unit_manager(slot8)
		local unit_list = World.unit_manager(slot8).get_units(slot8)
		local unit_map = {}
		local next_unit_map = {}
		local next_extension_map = {}
		local unit_name, path = nil
		slot15 = unit_list

		for _, unit in ipairs(slot14) do
			slot20 = unit
			unit_name = unit.name(slot19)
			path = "Units." .. unit_name
			slot22 = unit

			for index, extension_name in ipairs(unit.extensions(slot21)) do
				slot30 = unit
				slot32 = seen_map

				self.traverse_instances_recursively(slot24, self, path, extension_name, unit[extension_name](slot29), func, next_extension_map, info_map)

				slot25 = next_extension_map

				if next(slot24) ~= nil then
					next_unit_map[extension_name] = next_extension_map
					next_extension_map = {}
				end
			end

			slot20 = next_unit_map

			if next(slot19) ~= nil then
				slot20 = unit
				unit_map[unit.name(slot19)] = next_unit_map
				next_unit_map = {}
			end
		end

		slot15 = unit_map

		if next(slot14) ~= nil then
			populate_map.Units = unit_map
		end
	end

	slot8 = populate_map

	if next(slot7) ~= nil then
		return populate_map, info_map
	else
		return nil, info_map
	end

	return 
end
MemoryDebug.traverse_instances_recursively = function (self, path, key, value, func, populate_map, info_map, seen_map)
	info_map.count = info_map.count + 1

	if not seen_map[value] then
		info_map.seen_count = info_map.seen_count + 1
		slot16 = func
		local found, find_again = func(slot9, path, key, value, populate_map, info_map, seen_map)

		if found then
			info_map.found_count = info_map.found_count + 1
		end

		if not find_again then
			seen_map[value] = true
		end

		slot12 = value

		if type(slot11) == "table" then
			local next_populate_map = {}

			if path then
				slot13 = key

				if type(slot12) == "number" then
					path = path .. "[" .. key .. "]"
				else
					slot15 = key
					path = path .. "." .. tostring(slot14)
				end
			else
				path = key
			end

			slot13 = value

			for next_key, next_value in pairs(slot12) do
				slot25 = seen_map

				self.traverse_instances_recursively(slot17, self, path, next_key, next_value, func, next_populate_map, info_map)

				slot18 = next_populate_map

				if next(slot17) ~= nil then
					populate_map[next_key] = next_populate_map
					next_populate_map = {}
				end
			end
		end
	end

	return 
end
MemoryDebug.calc = function (self, map, seen_map)
	local global_populate_map = nil

	if map ~= nil then
		local function func(path, key, value, populate_map, info_map, seen_map, func)
			global_populate_map = global_populate_map or populate_map

			if key ~= nil then
				slot13 = global_populate_map

				self.add_calc(slot8, self, key, value, false)

				slot13 = global_populate_map

				self.add_calc(slot8, self, key, value, true)
			end

			return true, false
		end

		slot10 = map

		return self.traverse_instances(slot6, self, func, seen_map)
	else
		return nil, nil
	end

	return 
end
MemoryDebug.add_calc = function (self, key, value, is_key, populate_map)
	local check_value = (is_key and key) or value
	slot8 = check_value
	local check_value_type = type(slot7)

	if is_key then
		local bits = 128
		populate_map.key_bits = (populate_map.key_bits or 0) + bits
		populate_map.key_count = (populate_map.key_count or 0) + 1
		populate_map.total_bits = (populate_map.total_bits or 0) + bits
	end

	is_same_primitive_key = is_key and not self.PRIMITIVE_VALUE_TYPE_MAP[check_value_type] and key == value

	if not is_same_primitive_key then
		if check_value_type then
			local func_name = self.CALC_TYPE_FUNC_MAP[check_value_type]

			if func_name then
				slot13 = populate_map
				local bits = self[func_name](slot10, self, check_value)
				local bits_name = check_value_type .. "_bits"
				local count_name = check_value_type .. "_count"
				populate_map[bits_name] = (populate_map[bits_name] or 0) + bits
				populate_map[count_name] = (populate_map[count_name] or 0) + 1
				populate_map.total_bits = (populate_map.total_bits or 0) + bits
			else
				slot15 = check_value_type
				slot17 = is_key
				slot12 = "Unsupported value type \"" .. tostring(slot14) .. "\" (is key: " .. tostring(slot16) .. ")."

				Application.error(slot10, Application)
			end
		else
			slot14 = check_value
			slot16 = is_key
			slot11 = "Nil type for value \"" .. tostring(slot13) .. "\" (is key: " .. tostring(slot15) .. ")."

			Application.error(slot9, Application)
		end
	end

	return 
end
MemoryDebug.add_calc_string = function (self, value, populate_map)
	return #value * 2 * 8
end
MemoryDebug.add_calc_number = function (self, value, populate_map)
	return 32
end
MemoryDebug.add_calc_boolean = function (self, value, populate_map)
	return 1
end
MemoryDebug.add_calc_userdata = function (self, value, populate_map)
	return 128
end
MemoryDebug.add_calc_table = function (self, value, populate_map)
	return 0
end
MemoryDebug.add_calc_function = function (self, value, populate_map)
	return 128
end

if not ConsoleDebug then
	slot2 = BaseDebug
	slot0 = class(slot1)
end

ConsoleDebug = slot0
ConsoleDebug.IS_PREFERRED_DISABLED = true
ConsoleDebug.init = function (self)
	slot3 = self

	ConsoleDebug.super.init(slot2)

	return 
end
ConsoleDebug.destroy = function (self)
	slot3 = self

	self.clear(slot2)

	return 
end
ConsoleDebug.set_enabled = function (self, enabled)
	local was_enabled = self._enabled
	slot6 = enabled

	ConsoleDebug.super.set_enabled(slot4, self)

	if not was_enabled ~= not enabled then
		if enabled then
			slot5 = self

			self.setup_controller(slot4)

			slot12 = "hijacked_print"

			managers.debug.hijack.hijack_func(slot4, managers.debug.hijack, _G, "print", callback(slot9, self, self))

			slot7 = "debug"
			slot12 = "hijacked_debug"

			managers.debug.hijack.hijack_func(slot4, managers.debug.hijack, Application, callback(true, self, self))

			slot7 = "error"
			slot12 = "hijacked_error"

			managers.debug.hijack.hijack_func(slot4, managers.debug.hijack, Application, callback(true, self, self))

			slot7 = "stack_dump"
			slot12 = "hijacked_stack_dump"

			managers.debug.hijack.hijack_func(slot4, managers.debug.hijack, Application, callback(true, self, self))

			slot5 = self._workspace

			if not alive(slot4) then
				slot5 = self

				self.setup(slot4)
			end

			slot5 = self

			self.invalidate(slot4)
		else
			slot5 = self

			self.destroy_controller(slot4)

			slot8 = true

			managers.debug.hijack.unhijack_func(slot4, managers.debug.hijack, _G, "print")

			slot7 = "debug"

			managers.debug.hijack.unhijack_func(slot4, managers.debug.hijack, Application)

			slot7 = "error"

			managers.debug.hijack.unhijack_func(slot4, managers.debug.hijack, Application)

			slot7 = "stack_dump"

			managers.debug.hijack.unhijack_func(slot4, managers.debug.hijack, Application)
		end
	end

	return 
end
ConsoleDebug.hijacked_print = function (self, ...)
	_G.hijacked_print(...)

	slot3 = self

	self.add_print(slot2, ...)

	return 
end
ConsoleDebug.hijacked_debug = function (self, app, ...)
	slot4 = app

	app.hijacked_debug(slot3, ...)

	slot4 = self

	self.add_debug(slot3, ...)

	return 
end
ConsoleDebug.hijacked_error = function (self, app, ...)
	slot4 = app

	app.hijacked_error(slot3, ...)

	slot4 = self

	self.add_error(slot3, ...)

	return 
end
ConsoleDebug.hijacked_stack_dump = function (self, app, ...)
	slot4 = app

	app.hijacked_stack_dump(slot3, ...)

	slot4 = self
	slot8 = 3

	self.add_print(slot3, self.get_stack_dump_text(slot6, self))

	return 
end
ConsoleDebug.get_stack_dump_text = function (self, skip_level)
	local text = nil
	local level = (skip_level or 0) + 1

	while true do
		slot7 = "Sl"
		local info = debug.getinfo(slot5, level)

		if not info then
			break
		else
			if text then
				text = text .. "\n"
			else
				text = ""
			end

			if info.what == "C" then
				slot10 = info.currentline
				text = text .. string.format(slot7, "%s:%d (C++ method)", info.source)
			else
				slot10 = info.currentline
				text = text .. string.format(slot7, "%s:%d", info.source)
			end
		end

		level = level + 1
	end

	return text or ""
end
ConsoleDebug.clear = function (self)
	slot3 = self

	ConsoleDebug.super.clear(slot2)

	slot3 = self._workspace

	if alive(slot2) then
		slot3 = self._workspace
		slot3 = self._workspace.panel(slot2)

		self._workspace.panel(slot2).clear(slot2)

		slot3 = Overlay
		slot4 = self._workspace

		Overlay.gui(slot2).destroy_workspace(slot2, Overlay.gui(slot2))
	end

	slot3 = self

	self.destroy_controller(slot2)

	self._workspace = nil
	self._panel = nil
	self._text_gui = nil
	self._text_list = nil
	self._command_text_gui = nil
	self._scroll = nil

	return 
end
ConsoleDebug.toggle_visible = function (self)
	slot6 = self
	slot4 = not self.get_visible(slot5)

	self.set_visible(slot2, self)

	return 
end
ConsoleDebug.set_visible = function (self, visible)
	if not self._visible ~= not visible then
		self._visible = visible
		slot4 = self._workspace

		if not alive(slot3) then
			slot4 = self

			self.setup(slot3)
		end

		if visible then
			slot4 = self._workspace

			self._workspace.show(slot3)
		else
			slot4 = self._workspace

			self._workspace.hide(slot3)
		end
	end

	return 
end
ConsoleDebug.get_visible = function (self)
	return self._visible
end
ConsoleDebug.add_print = function (self, ...)
	slot4 = self.get_arg_text(slot5, ...)
	slot9 = 1

	self.add_text(slot2, self, Color(self, 1, 0))

	return 
end
ConsoleDebug.add_debug = function (self, ...)
	slot4 = self.get_arg_text(slot5, ...)
	slot9 = 0.2627450980392157

	self.add_text(slot2, self, Color(self, 0.23529411764705882, 0.6352941176470588))

	return 
end
ConsoleDebug.add_error = function (self, ...)
	slot4 = self.get_arg_text(slot5, ...)
	slot9 = 0

	self.add_text(slot2, self, Color(self, 1, 0))

	return 
end
ConsoleDebug.get_arg_text = function (self, ...)
	local text = ""
	slot4 = {
		...
	}

	for i, arg in ipairs(slot3) do
		if 1 < i then
			text = text .. "\t"
		end

		slot10 = arg
		text = text .. tostring(slot9)
	end

	return text
end
ConsoleDebug.add_text = function (self, text, color)
	slot5 = self._workspace

	if not alive(slot4) then
		slot5 = self

		self.setup(slot4)
	end

	slot7 = text
	slot7 = "    "
	local formatted_text = string.gsub(slot4, tostring(slot6), "\t")
	local text_data = {}
	slot7 = TimerManager
	slot7 = TimerManager.wall("\t")
	text_data.time = TimerManager.wall("\t").time("\t")
	text_data.text = formatted_text
	text_data.color = color
	slot8 = text_data

	table.insert("\t", self._text_list)

	if 0 < self._scroll then
		self._scroll = self._scroll + 1
	end

	slot7 = self

	self.invalidate(slot6)

	return 
end
ConsoleDebug.invalidate = function (self)
	slot3 = self._workspace

	if alive(slot2) then
		local old_command_text = ""
		slot4 = self._command_text_gui

		if alive(slot3) then
			slot4 = self._command_text_gui
			old_command_text = self._command_text_gui.text(slot3)
		end

		slot4 = self._panel

		self._panel.clear(slot3)

		slot4 = self._scroll
		local floored_scroll = math.floor(slot3)
		local index = #self._text_list - floored_scroll
		local config = {
			font = "core/fonts/diesel",
			font_size = 15,
			layer = 1000000,
			wrap = true
		}
		slot7 = self._panel
		config.width = self._panel.width(slot6)
		local y = self._panel.height(slot6) - config.font_size
		config.color = Color.white
		config.text = old_command_text
		slot9 = config
		self._command_text_gui = self._panel.text(self._panel, self._panel)

		function slot9(o, s)
			slot5 = s

			o.replace_text(slot3, o)

			return 
		end

		self._command_text_gui.enter_text(self._panel, self._command_text_gui)
		self._command_text_gui.key_press(self._panel, self._command_text_gui)

		slot11 = self._command_text_gui
		slot9 = config.font_size
		local command_text_height = math.max(self._panel, self._command_text_gui.line_height(function (o, key)

			-- Decompilation error in this vicinity:
			slot4 = o
			local s, e = o.selection(slot3)
			slot6 = "enter"

			return 
		end) * self._command_text_gui.number_of_lines(self._command_text_gui))
		y = y - command_text_height
		slot10 = command_text_height

		self._command_text_gui.set_height(self._command_text_gui.line_height(function (o, key)

			-- Decompilation error in this vicinity:
			slot4 = o
			local s, e = o.selection(slot3)
			slot6 = "enter"

			return 
		end) * self._command_text_gui.number_of_lines(self._command_text_gui), self._command_text_gui)

		slot10 = y

		self._command_text_gui.set_y(self._command_text_gui.line_height(function (o, key)

			-- Decompilation error in this vicinity:
			slot4 = o
			local s, e = o.selection(slot3)
			slot6 = "enter"

			return 
		end) * self._command_text_gui.number_of_lines(self._command_text_gui), self._command_text_gui)

		y = y - command_text_height
		local remainder_scroll = self._scroll - floored_scroll
		local scroll_first = 0 < remainder_scroll

		while 0 < index and 0 < y do

			-- Decompilation error in this vicinity:
			--- BLOCK #0 107-107, warpins: 1 ---
			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 108-112, warpins: 1 ---
			local text_data = self._text_list[index]
			config.color = text_data.color or Color.white
			slot14 = text_data.text
			config.text = string.format(slot11, "[%.2f] %s", text_data.time)
			slot13 = config
			local text_gui = self._panel.text(slot11, self._panel)
			slot14 = text_gui
			local height = text_gui.line_height(self._panel) * text_gui.number_of_lines(text_gui)

			--- END OF BLOCK #1 ---

			FLOW; TARGET BLOCK #2



			-- Decompilation error in this vicinity:
			--- BLOCK #2 115-136, warpins: 2 ---
			if scroll_first then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 137-139, warpins: 1 ---
				y = y + remainder_scroll * height
				scroll_first = false
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #2 ---

			FLOW; TARGET BLOCK #3



			-- Decompilation error in this vicinity:
			--- BLOCK #3 140-150, warpins: 2 ---
			y = y - height
			slot15 = height

			text_gui.set_height(slot13, text_gui)

			slot15 = y

			text_gui.set_y(slot13, text_gui)

			index = index - 1
			--- END OF BLOCK #3 ---

			FLOW; TARGET BLOCK #4



			-- Decompilation error in this vicinity:
			--- BLOCK #4 151-151, warpins: 2 ---
			--- END OF BLOCK #4 ---



		end
	end

	return 
end
ConsoleDebug.setup = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-14, warpins: 1 ---
	local gui_scene = Overlay.gui(slot2)
	slot4 = gui_scene
	self._workspace = gui_scene.create_screen_workspace(Overlay)
	slot4 = Input
	local keyboard = Input.keyboard(Overlay)

	if keyboard then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 15-19, warpins: 1 ---
		slot5 = keyboard

		if keyboard.enabled(slot4) then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 20-24, warpins: 1 ---
			slot5 = keyboard

			if keyboard.connected(slot4) then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 25-29, warpins: 1 ---
				slot6 = keyboard

				self._workspace.connect_keyboard(slot4, self._workspace)
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 30-65, warpins: 4 ---
	slot5 = self._workspace
	slot8 = "core/guis/core_debug_manager"
	local gui = self._workspace.panel(slot4).gui(slot4, Idstring(slot7))
	slot6 = managers.viewport
	local safe_rect = managers.viewport.get_safe_rect_pixels(self._workspace.panel(slot4))
	local config = {}
	config.x = safe_rect.x
	config.y = safe_rect.y
	config.width = safe_rect.width
	config.height = safe_rect.height
	config.halign = "grow"
	config.valign = "grow"
	slot9 = config
	self._panel = gui.panel(slot7, gui)

	if self._visible then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 66-70, warpins: 1 ---
		slot8 = self._workspace

		self._workspace.show(slot7)
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 71-74, warpins: 1 ---
		slot8 = self._workspace

		self._workspace.hide(slot7)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 75-82, warpins: 2 ---
	self._text_list = {}
	self._scroll = 0
	slot8 = self

	self.setup_controller(slot7)

	return 
	--- END OF BLOCK #2 ---



end
ConsoleDebug.setup_controller = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if not self._controller and self._enabled then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 7-49, warpins: 1 ---
		self._controller = managers.controller.create_controller(slot2, managers.controller, "core_debug_console", nil)
		slot4 = "toggle_console"
		slot9 = "toggle_visible"

		self._controller.add_trigger(slot2, self._controller, callback(true, self, self))

		slot4 = "console_scroll_page_up"
		slot9 = "scroll_page_up"

		self._controller.add_trigger(slot2, self._controller, callback(true, self, self))

		slot4 = "console_scroll_page_down"
		slot9 = "scroll_page_down"

		self._controller.add_trigger(slot2, self._controller, callback(true, self, self))

		slot3 = self._controller

		self._controller.enable(slot2)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 50-50, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
ConsoleDebug.destroy_controller = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._controller then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-9, warpins: 1 ---
		slot3 = self._controller

		self._controller.destroy(slot2)

		self._controller = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 10-10, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end
ConsoleDebug.update = function (self, t, dt)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._enabled and self._visible and self._scroll then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 10-22, warpins: 1 ---
		slot6 = "console_scroll_up"
		local up = self._controller.get_input_float(slot4, self._controller)
		slot7 = "console_scroll_down"
		local down = self._controller.get_input_float(self._controller, self._controller)
		local y = up - down

		if y ~= 0 then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 23-29, warpins: 1 ---
			slot9 = self._scroll + y * dt * 10

			self.set_scroll(slot7, self)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 30-30, warpins: 5 ---
	return 
	--- END OF BLOCK #1 ---



end
ConsoleDebug.scroll_page_up = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._scroll and self._visible then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 7-10, warpins: 1 ---
		slot4 = 10

		self.add_scroll(slot2, self)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 11-11, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
ConsoleDebug.scroll_page_down = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._scroll and self._visible then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 7-10, warpins: 1 ---
		slot4 = -10

		self.add_scroll(slot2, self)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 11-11, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
ConsoleDebug.add_scroll = function (self, scroll)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot5 = self._scroll + scroll

	self.set_scroll(slot3, self)

	return 
	--- END OF BLOCK #0 ---



end
ConsoleDebug.set_scroll = function (self, scroll)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-17, warpins: 1 ---
	local old_scroll = self._scroll
	slot6 = 0
	slot10 = #self._text_list - 1
	self._scroll = math.clamp(slot4, scroll, math.max(slot8, 0))

	if old_scroll ~= self._scroll then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 18-20, warpins: 1 ---
		slot5 = self

		self.invalidate(slot4)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 21-21, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end

if not MenuDebug then

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1071-1073, warpins: 1 ---
	slot2 = BaseDebug
	slot0 = class(slot1)
	--- END OF BLOCK #0 ---



end

MenuDebug = slot0
MenuDebug.IS_PREFERRED_DISABLED = true
MenuDebug.init = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot3 = self

	MenuDebug.super.init(slot2)

	return 
	--- END OF BLOCK #0 ---



end
MenuDebug.destroy = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-8, warpins: 1 ---
	slot3 = self

	self.destroy_controller(slot2)

	slot3 = self._workspace

	if alive(slot2) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 9-24, warpins: 1 ---
		slot3 = Overlay
		slot4 = self._workspace

		Overlay.gui(slot2).destroy_workspace(slot2, Overlay.gui(slot2))

		self._workspace = nil
		self._panel = nil
		self._option_panel = nil
		self._background_rect = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 25-27, warpins: 2 ---
	if self._resolution_changed_callback_id then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 28-35, warpins: 1 ---
		slot4 = self._resolution_changed_callback_id

		managers.viewport.remove_resolution_changed_func(slot2, managers.viewport)

		self._resolution_changed_callback_id = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 36-36, warpins: 2 ---
	return 
	--- END OF BLOCK #2 ---



end
MenuDebug.destroy_controller = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._controller then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-14, warpins: 1 ---
		slot5 = false

		self.set_controller_triggers_enabled(slot2, self, self._controller)

		slot3 = self._controller

		self._controller.destroy(slot2)

		self._controller = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 15-15, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.set_enabled = function (self, enabled)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-11, warpins: 1 ---
	local was_enabled = self._enabled
	slot6 = enabled

	MenuDebug.super.set_enabled(slot4, self)

	if not was_enabled ~= not enabled then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 12-14, warpins: 1 ---
		local data_controller = self._menu_data and self._menu_data.controller

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 17-18, warpins: 2 ---
		if data_controller then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 19-23, warpins: 1 ---
			slot8 = enabled

			self.set_controller_triggers_enabled(slot5, self, data_controller)
			--- END OF BLOCK #0 ---



		end

		--- END OF BLOCK #1 ---

		FLOW; TARGET BLOCK #2



		-- Decompilation error in this vicinity:
		--- BLOCK #2 24-25, warpins: 2 ---
		if enabled then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 26-27, warpins: 1 ---
			if not data_controller then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 28-30, warpins: 1 ---
				slot6 = self

				self.setup_controller(slot5)
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 31-34, warpins: 2 ---
			slot6 = self

			self.setup_menu(slot5)
			--- END OF BLOCK #1 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 35-37, warpins: 1 ---
			slot6 = self

			self.destroy(slot5)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #2 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 38-38, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.toggle_visible = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-8, warpins: 1 ---
	slot6 = self
	slot4 = not self.get_visible(slot5)

	self.set_visible(slot2, self)

	return 
	--- END OF BLOCK #0 ---



end
MenuDebug.set_visible = function (self, visible)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	local always_visible = self._menu_data and self._menu_data.always_visible

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 6-10, warpins: 2 ---
	if not self._visible ~= not visible and (visible or not always_visible) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 15-18, warpins: 2 ---
		self._visible = visible

		if self._workspace then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 19-20, warpins: 1 ---
			if visible then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 21-25, warpins: 1 ---
				slot5 = self._workspace

				self._workspace.show(slot4)
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 26-32, warpins: 1 ---
				slot5 = self._workspace

				self._workspace.hide(slot4)

				if self._menu_data and self._menu_data.auto_reset then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 37-47, warpins: 1 ---
					self._current_menu_data = nil
					self._prev_menu_data_list = nil
					self._prev_menu_index_list = nil
					self._current_menu_index = nil
					slot5 = self

					self.setup_menu(slot4)
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 48-48, warpins: 7 ---
	return 
	--- END OF BLOCK #2 ---



end
MenuDebug.get_visible = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	return self._visible
	--- END OF BLOCK #0 ---



end
MenuDebug.clear = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-11, warpins: 1 ---
	slot3 = self

	MenuDebug.super.clear(slot2)

	self._menu_data = nil
	slot3 = self

	self.setup_menu(slot2)

	return 
	--- END OF BLOCK #0 ---



end
MenuDebug.setup_controller = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if not self._controller then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-22, warpins: 1 ---
		slot6 = true
		self._controller = managers.controller.create_controller(slot2, managers.controller, "core_debug_menu", nil)
		slot5 = true

		self.set_controller_triggers_enabled(slot2, self, self._controller)

		slot4 = true

		self._controller.set_enabled(slot2, self._controller)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 23-23, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.set_controller_triggers_enabled = function (self, controller, enabled)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	if enabled then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 3-5, warpins: 1 ---
		if not self._toggle_visible_func then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 6-49, warpins: 1 ---
			slot7 = "toggle_visible"
			self._toggle_visible_func = callback(slot4, self, self)
			slot8 = -1
			self._change_selection_down_func = callback(slot4, self, self, "change_selection")
			slot8 = 1
			self._change_selection_up_func = callback(slot4, self, self, "change_selection")
			slot7 = "confirm_button_pressed"
			self._confirm_func = callback(slot4, self, self)
			slot7 = "cancel_button_pressed"
			self._cancel_func = callback(slot4, self, self)
			slot7 = "left_button_pressed"
			self._left_func = callback(slot4, self, self)
			slot7 = "right_button_pressed"
			self._right_func = callback(slot4, self, self)
			--- END OF BLOCK #0 ---



		end

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 50-85, warpins: 2 ---
		slot7 = self._toggle_visible_func

		controller.add_trigger(slot4, controller, "toggle_menu")

		slot7 = self._change_selection_down_func

		controller.add_trigger(slot4, controller, "menu_up")

		slot7 = self._change_selection_up_func

		controller.add_trigger(slot4, controller, "menu_down")

		slot7 = self._confirm_func

		controller.add_trigger(slot4, controller, "confirm")

		slot7 = self._cancel_func

		controller.add_trigger(slot4, controller, "cancel")

		slot7 = self._left_func

		controller.add_trigger(slot4, controller, "menu_left")

		slot7 = self._right_func

		controller.add_trigger(slot4, controller, "menu_right")
		--- END OF BLOCK #1 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 86-88, warpins: 1 ---
		if self._toggle_visible_func then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 89-137, warpins: 1 ---
			slot7 = self._toggle_visible_func

			controller.remove_trigger(slot4, controller, "toggle_menu")

			slot7 = self._change_selection_down_func

			controller.remove_trigger(slot4, controller, "menu_up")

			slot7 = self._change_selection_up_func

			controller.remove_trigger(slot4, controller, "menu_down")

			slot7 = self._confirm_func

			controller.remove_trigger(slot4, controller, "confirm")

			slot7 = self._cancel_func

			controller.remove_trigger(slot4, controller, "cancel")

			slot7 = self._left_func

			controller.remove_trigger(slot4, controller, "menu_left")

			slot7 = self._right_func

			controller.remove_trigger(slot4, controller, "menu_right")

			self._toggle_visible_func = nil
			self._change_selection_down_func = nil
			self._change_selection_up_func = nil
			self._confirm_func = nil
			self._cancel_func = nil
			self._left_func = nil
			self._right_func = nil
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 138-138, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.change_selection = function (self, change)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	slot5 = 1
	local max_index = math.max(slot3, (self._current_menu_data and #self._current_menu_data) or 1)
	self._current_menu_index = (((self._current_menu_index or 1) + change) - 1) % max_index + 1
	slot5 = self

	self.setup_menu((self._current_menu_data and #self._current_menu_data) or 1)

	return 
	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 11-15, warpins: 2 ---
	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 17-25, warpins: 2 ---
	--- END OF BLOCK #2 ---



end
MenuDebug.confirm_button_pressed = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._current_menu_data then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-7, warpins: 1 ---
		local next_menu_data = self._current_menu_data[self._current_menu_index or 1]

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 9-11, warpins: 2 ---
		if next_menu_data then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 12-15, warpins: 1 ---
			if 0 < #next_menu_data then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 16-18, warpins: 1 ---
				self._prev_menu_data_list = self._prev_menu_data_list or {}
				slot5 = self._current_menu_data

				table.insert(slot3, self._prev_menu_data_list)

				self._prev_menu_index_list = self._prev_menu_index_list or {}
				slot5 = self._current_menu_index or 1

				table.insert(slot3, self._prev_menu_index_list)

				self._current_menu_data = next_menu_data
				self._current_menu_index = nil
				slot4 = self

				self.setup_menu(slot3)
				--- END OF BLOCK #0 ---

				FLOW; TARGET BLOCK #1



				-- Decompilation error in this vicinity:
				--- BLOCK #1 20-28, warpins: 2 ---
				--- END OF BLOCK #1 ---

				FLOW; TARGET BLOCK #2



				-- Decompilation error in this vicinity:
				--- BLOCK #2 30-36, warpins: 2 ---
				--- END OF BLOCK #2 ---

				FLOW; TARGET BLOCK #3



				-- Decompilation error in this vicinity:
				--- BLOCK #3 38-44, warpins: 2 ---
				--- END OF BLOCK #3 ---



			end

			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 45-47, warpins: 2 ---
			if next_menu_data.callback_func then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 48-50, warpins: 1 ---
				slot4 = next_menu_data

				next_menu_data.callback_func(slot3)
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #1 ---



		end
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 51-51, warpins: 4 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.cancel_button_pressed = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._prev_menu_data_list then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-28, warpins: 1 ---
		local prev_menu_data = self._prev_menu_data_list[#self._prev_menu_data_list]
		slot5 = #self._prev_menu_data_list

		table.remove(slot3, self._prev_menu_data_list)

		local prev_menu_index = self._prev_menu_index_list[#self._prev_menu_index_list]
		slot6 = #self._prev_menu_index_list

		table.remove(self._prev_menu_data_list, self._prev_menu_index_list)

		slot5 = self._prev_menu_data_list

		if not next(self._prev_menu_data_list) then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 29-32, warpins: 1 ---
			self._prev_menu_data_list = nil
			self._prev_menu_index_list = nil
			--- END OF BLOCK #0 ---



		end

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 33-38, warpins: 2 ---
		self._current_menu_data = prev_menu_data
		self._current_menu_index = prev_menu_index
		slot5 = self

		self.setup_menu(slot4)
		--- END OF BLOCK #1 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 39-42, warpins: 1 ---
		slot4 = false

		self.set_visible(slot2, self)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 43-43, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.left_button_pressed = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._current_menu_data then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-7, warpins: 1 ---
		local menu_data = self._current_menu_data[self._current_menu_index or 1]

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 9-11, warpins: 2 ---
		if menu_data then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 12-14, warpins: 1 ---
			local callback_func = menu_data.left_callback_func

			if callback_func then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 15-17, warpins: 1 ---
				slot5 = self._current_menu_data

				callback_func(slot4)
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 18-18, warpins: 4 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.right_button_pressed = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._current_menu_data then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-7, warpins: 1 ---
		local menu_data = self._current_menu_data[self._current_menu_index or 1]

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 9-11, warpins: 2 ---
		if menu_data then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 12-14, warpins: 1 ---
			local callback_func = menu_data.right_callback_func

			if callback_func then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 15-17, warpins: 1 ---
				slot5 = self._current_menu_data

				callback_func(slot4)
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 18-18, warpins: 4 ---
	return 
	--- END OF BLOCK #1 ---



end
MenuDebug.setup_menu = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if not self._resolution_changed_callback_id then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-14, warpins: 1 ---
		slot3 = managers.viewport
		slot8 = "setup_menu"
		self._resolution_changed_callback_id = managers.viewport.add_resolution_changed_func(slot2, callback(slot5, self, self))
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 15-19, warpins: 2 ---
	slot3 = self._workspace

	if not alive(slot2) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 20-33, warpins: 1 ---
		slot3 = Overlay
		slot3 = Overlay.gui(slot2)
		self._workspace = Overlay.gui(slot2).create_screen_workspace(slot2)
		slot3 = self._workspace
		self._panel = self._workspace.panel(slot2)
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 34-37, warpins: 1 ---
		slot3 = self._panel

		self._panel.clear(slot2)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 38-40, warpins: 2 ---
	if self._visible then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 41-45, warpins: 1 ---
		slot3 = self._workspace

		self._workspace.show(slot2)
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 46-49, warpins: 1 ---
		slot3 = self._workspace

		self._workspace.hide(slot2)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 50-57, warpins: 2 ---
	slot3 = self._panel
	self._option_panel = self._panel.panel(slot2)
	self._current_menu_data = self._current_menu_data or self._menu_data
	self._background_rect = nil

	--- END OF BLOCK #3 ---

	FLOW; TARGET BLOCK #4



	-- Decompilation error in this vicinity:
	--- BLOCK #4 59-64, warpins: 2 ---
	if self._current_menu_data then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 65-68, warpins: 1 ---
		local bg_color = self._current_menu_data.bg_color or self._menu_data.bg_color

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 71-72, warpins: 2 ---
		if bg_color then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 73-79, warpins: 1 ---
			slot5 = {
				color = bg_color
			}
			self._background_rect = self._panel.rect(slot3, self._panel)
			--- END OF BLOCK #0 ---



		end

		--- END OF BLOCK #1 ---

		FLOW; TARGET BLOCK #2



		-- Decompilation error in this vicinity:
		--- BLOCK #2 80-100, warpins: 2 ---
		local option_config = {}
		option_config.layer = 1
		slot5 = TimerManager
		local t = TimerManager.main(slot4).time(slot4)
		slot6 = TimerManager
		local dt = TimerManager.main(TimerManager.main(slot4)).delta_time(TimerManager.main(slot4))
		slot7 = self._current_menu_data

		--- END OF BLOCK #2 ---

		FLOW; TARGET BLOCK #3



		-- Decompilation error in this vicinity:
		--- BLOCK #3 101-185, warpins: 0 ---
		for index, option_data in ipairs(TimerManager.main(TimerManager.main(slot4))) do

			-- Decompilation error in this vicinity:
			--- BLOCK #0 101-103, warpins: 1 ---
			option_config.font = option_data.font or self._menu_data.font or "core/fonts/diesel"
			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 109-112, warpins: 3 ---
			--- END OF BLOCK #1 ---

			FLOW; TARGET BLOCK #2



			-- Decompilation error in this vicinity:
			--- BLOCK #2 131-132, warpins: 2 ---
			option_config.text = slot10

			if index == (self._current_menu_index or 1) then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 133-135, warpins: 1 ---
				option_config.color = option_data.select_color or self._menu_data.select_color or Color.green
				--- END OF BLOCK #0 ---

				FLOW; TARGET BLOCK #1



				-- Decompilation error in this vicinity:
				--- BLOCK #1 142-143, warpins: 3 ---
				--- END OF BLOCK #1 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 144-146, warpins: 1 ---
				option_config.color = option_data.color or self._menu_data.color or Color.red
				--- END OF BLOCK #0 ---

				FLOW; TARGET BLOCK #1



				-- Decompilation error in this vicinity:
				--- BLOCK #1 153-153, warpins: 3 ---
				--- END OF BLOCK #1 ---



			end

			--- END OF BLOCK #2 ---

			FLOW; TARGET BLOCK #3



			-- Decompilation error in this vicinity:
			--- BLOCK #3 154-156, warpins: 2 ---
			if not self._preloaded_font_list or not self._preloaded_font_list[option_config.font] then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 162-172, warpins: 2 ---
				slot12 = Overlay
				slot13 = option_config.font

				Overlay.gui(slot11).preload_font(slot11, Overlay.gui(slot11))

				self._preloaded_font_list = self._preloaded_font_list or {}
				self._preloaded_font_list[option_config.font] = true
				--- END OF BLOCK #0 ---

				FLOW; TARGET BLOCK #1



				-- Decompilation error in this vicinity:
				--- BLOCK #1 174-178, warpins: 2 ---
				--- END OF BLOCK #1 ---



			end

			--- END OF BLOCK #3 ---

			FLOW; TARGET BLOCK #4



			-- Decompilation error in this vicinity:
			--- BLOCK #4 179-183, warpins: 2 ---
			slot13 = option_config

			self._option_panel.text(slot11, self._option_panel)
			--- END OF BLOCK #4 ---

			FLOW; TARGET BLOCK #5



			-- Decompilation error in this vicinity:
			--- BLOCK #5 184-185, warpins: 2 ---
			--- END OF BLOCK #5 ---



		end

		--- END OF BLOCK #3 ---

		FLOW; TARGET BLOCK #4



		-- Decompilation error in this vicinity:
		--- BLOCK #4 186-188, warpins: 1 ---
		slot7 = self

		self.setup_menu_shape(slot6)
		--- END OF BLOCK #4 ---



	end

	--- END OF BLOCK #4 ---

	FLOW; TARGET BLOCK #5



	-- Decompilation error in this vicinity:
	--- BLOCK #5 189-189, warpins: 2 ---
	return 
	--- END OF BLOCK #5 ---



end
MenuDebug.setup_menu_shape = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	local res = RenderSettings.resolution
	local option_spacing = self._current_menu_data.option_spacing or 5
	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 8-21, warpins: 2 ---
	local option_w = 0
	local option_h = 0
	local select_y = 0
	slot12 = res.y

	self._panel.set_shape(slot7, self._panel, 0, 0, res.x)

	if self._background_rect then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 22-29, warpins: 1 ---
		slot12 = res.y

		self._background_rect.set_shape(slot7, self._background_rect, 0, 0, res.x)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 30-36, warpins: 2 ---
	slot10 = self._option_panel

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 37-74, warpins: 0 ---
	for index, option in ipairs(self._option_panel.children(slot9)) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 37-43, warpins: 1 ---
		local option_data = self._current_menu_data[index]
		slot15 = option_data.font_size or self._menu_data.font_size or 20

		option.set_font_size(slot13, option)

		slot14 = option
		local x, y, w, h = option.text_rect(slot13)

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 49-54, warpins: 3 ---
		if option_w < w then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 55-55, warpins: 1 ---
			option_w = w
			--- END OF BLOCK #0 ---



		end

		--- END OF BLOCK #1 ---

		FLOW; TARGET BLOCK #2



		-- Decompilation error in this vicinity:
		--- BLOCK #2 60-61, warpins: 2 ---
		if index == (self._current_menu_index or 0) then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 62-63, warpins: 1 ---
			select_y = option_h + h / 2
			--- END OF BLOCK #0 ---



		end

		--- END OF BLOCK #2 ---

		FLOW; TARGET BLOCK #3



		-- Decompilation error in this vicinity:
		--- BLOCK #3 64-72, warpins: 2 ---
		slot22 = h

		option.set_shape(slot17, option, 0, option_h, w)

		option_h = option_h + h + option_spacing
		--- END OF BLOCK #3 ---

		FLOW; TARGET BLOCK #4



		-- Decompilation error in this vicinity:
		--- BLOCK #4 73-74, warpins: 2 ---
		--- END OF BLOCK #4 ---



	end

	--- END OF BLOCK #3 ---

	FLOW; TARGET BLOCK #4



	-- Decompilation error in this vicinity:
	--- BLOCK #4 75-77, warpins: 1 ---
	if 0 < option_h then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 78-78, warpins: 1 ---
		option_h = option_h - option_spacing
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #4 ---

	FLOW; TARGET BLOCK #5



	-- Decompilation error in this vicinity:
	--- BLOCK #5 79-90, warpins: 2 ---
	local panel_y = (res.y - option_h) / 2
	slot9 = managers.viewport
	local safe_rect = managers.viewport.get_safe_rect_pixels(slot8)
	local fade_dist = 200

	if safe_rect.height < option_h then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 91-100, warpins: 1 ---
		panel_y = panel_y - select_y + option_h / 2
		slot13 = self._option_panel

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 101-146, warpins: 0 ---
		for _, option in ipairs(self._option_panel.children(slot12)) do

			-- Decompilation error in this vicinity:
			--- BLOCK #0 101-119, warpins: 1 ---
			slot18 = option
			slot16 = (panel_y + option.y(slot17)) - safe_rect.y - safe_rect.height / 2
			local center_dist = math.abs(slot15)
			local edge_dist = safe_rect.height / 2 - center_dist
			local fade = nil

			if 0 < fade_dist then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 120-127, warpins: 1 ---
				slot21 = 1
				fade = math.clamp(slot18, edge_dist / fade_dist, 0)
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 128-130, warpins: 1 ---
				if 0 < edge_dist then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 131-132, warpins: 1 ---
					fade = 1
					--- END OF BLOCK #0 ---



				else

					-- Decompilation error in this vicinity:
					--- BLOCK #0 133-133, warpins: 1 ---
					fade = 0
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 134-144, warpins: 3 ---
			local color = option.color(slot18)
			slot20 = option
			slot24 = color.alpha * fade

			option.set_color(option, color.with_alpha(slot22, color))
			--- END OF BLOCK #1 ---

			FLOW; TARGET BLOCK #2



			-- Decompilation error in this vicinity:
			--- BLOCK #2 145-146, warpins: 2 ---
			--- END OF BLOCK #2 ---



		end
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #5 ---

	FLOW; TARGET BLOCK #6



	-- Decompilation error in this vicinity:
	--- BLOCK #6 147-153, warpins: 2 ---
	slot13 = self._option_panel

	--- END OF BLOCK #6 ---

	FLOW; TARGET BLOCK #7



	-- Decompilation error in this vicinity:
	--- BLOCK #7 154-163, warpins: 0 ---
	for _, option in ipairs(self._option_panel.children(slot12)) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 154-161, warpins: 1 ---
		slot16 = option
		local x, y, w, h = option.text_rect(slot15)
		slot21 = (option_w - w) / 2

		option.set_x(slot19, option)
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 162-163, warpins: 2 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #7 ---

	FLOW; TARGET BLOCK #8



	-- Decompilation error in this vicinity:
	--- BLOCK #8 164-174, warpins: 1 ---
	slot15 = option_h

	self._option_panel.set_shape(slot10, self._option_panel, (res.x - option_w) / 2, panel_y, option_w)

	return 
	--- END OF BLOCK #8 ---



end
MenuDebug.set = function (self, menu_data)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	local old_data_controller = self._menu_data and self._menu_data.controller

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 6-7, warpins: 2 ---
	if old_data_controller then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 8-12, warpins: 1 ---
		slot7 = false

		self.set_controller_triggers_enabled(slot4, self, old_data_controller)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 13-27, warpins: 2 ---
	self._menu_data = menu_data
	self._current_menu_data = nil
	self._prev_menu_data_list = nil
	self._prev_menu_index_list = nil
	self._current_menu_index = nil
	slot5 = self

	self.setup_menu(slot4)

	local data_controller = self._menu_data and self._menu_data.controller

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 30-31, warpins: 2 ---
	if data_controller then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 32-39, warpins: 1 ---
		slot6 = self

		self.destroy_controller(slot5)

		slot8 = self._enabled

		self.set_controller_triggers_enabled(slot5, self, data_controller)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #3 ---

	FLOW; TARGET BLOCK #4



	-- Decompilation error in this vicinity:
	--- BLOCK #4 40-40, warpins: 2 ---
	return 
	--- END OF BLOCK #4 ---



end
MenuDebug.get_level = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	return (self._prev_menu_data_list and #self._prev_menu_data_list) or 0
	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 9-9, warpins: 2 ---
	--- END OF BLOCK #1 ---



end
MenuDebug.update = function (self, t, dt)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-19, warpins: 1 ---
	slot5 = TimerManager
	slot6 = TimerManager
	slot6 = TimerManager.main(TimerManager.main(slot4))
	dt = TimerManager.main(TimerManager.main(slot4)).delta_time(TimerManager.main(slot4))
	t = TimerManager.main(slot4).time(slot4)

	if self._current_menu_data then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 20-24, warpins: 1 ---
		local shape_changed = nil
		slot6 = self._current_menu_data

		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 25-53, warpins: 0 ---
		for index, option_data in ipairs(slot5) do

			-- Decompilation error in this vicinity:
			--- BLOCK #0 25-27, warpins: 1 ---
			local func = option_data.text_func

			if func then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 28-42, warpins: 1 ---
				slot13 = index - 1
				local option = self._option_panel.child(slot11, self._option_panel)
				local old_text = option.text(self._option_panel)
				slot16 = option_data
				local new_text = func(option, t, dt)
				shape_changed = shape_changed or old_text ~= new_text
				--- END OF BLOCK #0 ---

				FLOW; TARGET BLOCK #1



				-- Decompilation error in this vicinity:
				--- BLOCK #1 48-51, warpins: 3 ---
				slot16 = new_text

				option.set_text(slot14, option)
				--- END OF BLOCK #1 ---



			end
			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 52-53, warpins: 3 ---
			--- END OF BLOCK #1 ---



		end

		--- END OF BLOCK #1 ---

		FLOW; TARGET BLOCK #2



		-- Decompilation error in this vicinity:
		--- BLOCK #2 54-55, warpins: 1 ---
		if shape_changed then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 56-58, warpins: 1 ---
			slot6 = self

			self.setup_menu_shape(slot5)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #2 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 59-59, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end

return 
