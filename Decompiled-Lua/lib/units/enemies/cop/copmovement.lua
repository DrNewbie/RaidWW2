-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- Decompilation Error: _glue_flows(node)

-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
slot2 = "lib/units/enemies/cop/actions/lower_body/CopActionIdle"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/lower_body/CopActionWalk"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/full_body/CopActionAct"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/lower_body/CopActionTurn"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/full_body/CopActionHurt"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/lower_body/CopActionStand"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/lower_body/CopActionCrouch"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/upper_body/CopActionShoot"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/upper_body/CopActionReload"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/upper_body/CopActionTase"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/full_body/CopActionDodge"

require(slot1)

slot2 = "lib/units/enemies/cop/actions/full_body/CopActionWarp"

require(slot1)

slot2 = "lib/units/civilians/actions/lower_body/CivilianActionWalk"

require(slot1)

slot2 = "lib/units/civilians/actions/lower_body/EscortWithSuitcaseActionWalk"

require(slot1)

slot2 = "lib/units/enemies/tank/actions/lower_body/TankCopActionWalk"

require(slot1)

slot2 = "lib/units/enemies/flamer/actions/lower_body/FlamerActionWalk"

require(slot1)

slot2 = "lib/units/player_team/actions/lower_body/CriminalActionWalk"

require(slot1)

slot2 = "movement"
local ids_movement = Idstring(slot1)
local mvec3_set = mvector3.set
local mvec3_set_z = mvector3.set_z
local mvec3_lerp = mvector3.lerp
local mrot_set = mrotation.set_yaw_pitch_roll
local temp_vec1 = Vector3()
local temp_vec2 = Vector3()
local temp_vec3 = Vector3()
local stance_ctl_pts = {
	0,
	0,
	1,
	1
}
CopMovement = CopMovement or class()
CopMovement.set_friendly_fire = PlayerMovement.set_friendly_fire
CopMovement.friendly_fire = PlayerMovement.friendly_fire
slot14 = "a_weapon_left_front"
slot14 = "a_weapon_right_front"
slot14 = "Head"
slot14 = "units/vanilla/props/props_syringe/props_syringe"
CopMovement._gadgets = {
	aligns = {
		hand_l = Idstring(slot13),
		hand_r = Idstring(slot13),
		head = Idstring(slot13)
	},
	needle = {
		Idstring(slot13)
	}
}
local action_variants = {
	security = {
		idle = CopActionIdle,
		act = CopActionAct,
		walk = CopActionWalk,
		turn = CopActionTurn,
		hurt = CopActionHurt,
		stand = CopActionStand,
		crouch = CopActionCrouch,
		shoot = CopActionShoot,
		reload = CopActionReload,
		tase = CopActionTase,
		dodge = CopActionDodge,
		warp = CopActionWarp
	}
}
local security_variant = action_variants.security
action_variants.german_commander = security_variant
action_variants.german_og_commander = security_variant
action_variants.german_officer = security_variant
action_variants.german_grunt_light = security_variant
action_variants.german_grunt_light_mp38 = security_variant
action_variants.german_grunt_light_kar98 = security_variant
action_variants.german_grunt_light_shotgun = security_variant
action_variants.german_grunt_mid = security_variant
action_variants.german_grunt_mid_mp38 = security_variant
action_variants.german_grunt_mid_kar98 = security_variant
action_variants.german_grunt_mid_shotgun = security_variant
action_variants.german_grunt_heavy = security_variant
action_variants.german_grunt_heavy_mp38 = security_variant
action_variants.german_grunt_heavy_kar98 = security_variant
action_variants.german_grunt_heavy_shotgun = security_variant
action_variants.german_light = security_variant
action_variants.german_light_kar98 = security_variant
action_variants.german_light_shotgun = security_variant
action_variants.german_heavy = security_variant
action_variants.german_heavy_kar98 = security_variant
action_variants.german_heavy_shotgun = security_variant
action_variants.german_gasmask = security_variant
action_variants.german_gasmask_shotgun = security_variant
action_variants.german_gasmask_commander_backup = security_variant
action_variants.german_gasmask_commander_backup_shotgun = security_variant
action_variants.german_light_commander_backup = security_variant
action_variants.german_heavy_commander_backup = security_variant
action_variants.german_fallschirmjager_light = security_variant
action_variants.german_fallschirmjager_light_kar98 = security_variant
action_variants.german_fallschirmjager_light_shotgun = security_variant
action_variants.german_fallschirmjager_light_mp38 = security_variant
action_variants.german_fallschirmjager_heavy = security_variant
action_variants.german_fallschirmjager_heavy_kar98 = security_variant
action_variants.german_fallschirmjager_heavy_shotgun = security_variant
action_variants.german_fallschirmjager_heavy_mp38 = security_variant
action_variants.german_waffen_ss = security_variant
action_variants.german_waffen_ss_kar98 = security_variant
action_variants.german_waffen_ss_shotgun = security_variant
action_variants.german_gebirgsjager_light = security_variant
action_variants.german_gebirgsjager_light_kar98 = security_variant
action_variants.german_gebirgsjager_light_shotgun = security_variant
action_variants.german_gebirgsjager_light_mp38 = security_variant
action_variants.german_gebirgsjager_heavy = security_variant
action_variants.german_gebirgsjager_heavy_kar98 = security_variant
action_variants.german_gebirgsjager_heavy_shotgun = security_variant
action_variants.german_gebirgsjager_heavy_mp38 = security_variant
slot13 = security_variant
action_variants.german_flamer = clone(Idstring)
action_variants.german_flamer.walk = FlamerActionWalk
action_variants.german_sniper = security_variant
action_variants.german_spotter = security_variant
action_variants.soviet_nkvd_int_security_captain = security_variant
action_variants.soviet_nkvd_int_security_captain_b = security_variant
action_variants.gensec = security_variant
action_variants.cop = security_variant
action_variants.fbi = security_variant
action_variants.swat = security_variant
action_variants.heavy_swat = security_variant
action_variants.fbi_swat = security_variant
action_variants.fbi_heavy_swat = security_variant
action_variants.nathan = security_variant
action_variants.sniper = security_variant
action_variants.spotter = security_variant
action_variants.flamer = security_variant
action_variants.gangster = security_variant
action_variants.biker = security_variant
action_variants.mobster = security_variant
action_variants.mobster_boss = security_variant
action_variants.hector_boss = security_variant
action_variants.hector_boss_no_armor = security_variant
action_variants.dealer = security_variant
action_variants.biker_escape = security_variant
action_variants.city_swat = security_variant
action_variants.old_hoxton_mission = security_variant
slot13 = security_variant
action_variants.shield = clone(FlamerActionWalk)
action_variants.shield.hurt = ShieldActionHurt
slot13 = action_variants.shield
action_variants.phalanx_minion = clone(ShieldActionHurt)
slot13 = action_variants.shield
action_variants.phalanx_vip = clone(ShieldActionHurt)
slot13 = security_variant
action_variants.tank = clone(ShieldActionHurt)
action_variants.tank.walk = TankCopActionWalk
action_variants.tank_hw = action_variants.tank
action_variants.taser = security_variant
action_variants.inside_man = security_variant
action_variants.civilian = {
	idle = CopActionIdle,
	act = CopActionAct,
	walk = CivilianActionWalk,
	turn = CopActionTurn,
	hurt = CopActionHurt
}
action_variants.civilian_female = action_variants.civilian
action_variants.bank_manager = action_variants.civilian
action_variants.drunk_pilot = action_variants.civilian
action_variants.escort = action_variants.civilian
action_variants.escort.walk = EscortWithSuitcaseActionWalk
slot13 = action_variants.civilian
action_variants.escort_suitcase = clone(EscortWithSuitcaseActionWalk)
action_variants.escort_suitcase.walk = EscortWithSuitcaseActionWalk
slot13 = action_variants.civilian
action_variants.escort_prisoner = clone(EscortWithSuitcaseActionWalk)
action_variants.escort_prisoner.walk = EscortPrisonerActionWalk
action_variants.escort_cfo = action_variants.civilian
action_variants.escort_ralph = action_variants.civilian
slot13 = action_variants.civilian
action_variants.escort_undercover = clone(EscortPrisonerActionWalk)
action_variants.escort_undercover.walk = EscortWithSuitcaseActionWalk
slot13 = security_variant
action_variants.team_ai = clone(EscortWithSuitcaseActionWalk)
action_variants.team_ai.walk = CriminalActionWalk
action_variants.german = action_variants.team_ai
action_variants.british = action_variants.team_ai
action_variants.american = action_variants.team_ai
action_variants.russian = action_variants.team_ai
security_variant = nil
CopMovement._action_variants = action_variants
action_variants = nil
CopMovement._stance = {
	names = {
		"ntl",
		"hos",
		"cbt",
		"wnd"
	},
	blend = {
		0.8,
		0.5,
		0.3,
		0.4
	}
}
CopMovement.init = function (self, unit)
	self._unit = unit
	slot4 = self._unit
	self._machine = self._unit.anim_state_machine(slot3)
	slot4 = self._unit
	self._nav_tracker_id = self._unit.key(slot3)
	self._nav_tracker = nil
	self._root_blend_ref = 0
	slot4 = unit
	self._m_pos = unit.position(slot3)
	slot4 = self._m_pos
	self._m_stand_pos = mvector3.copy(slot3)
	slot5 = self._m_pos.z + 160

	mvec3_set_z(slot3, self._m_stand_pos)

	self._m_com = math.lerp(slot3, self._m_pos, self._m_stand_pos)
	slot4 = unit
	slot7 = "Head"
	self._obj_head = unit.get_object(slot3, Idstring(0.5))
	slot4 = self._obj_head
	self._m_head_rot = self._obj_head.rotation(slot3)
	slot4 = self._obj_head
	self._m_head_pos = self._obj_head.position(slot3)
	slot4 = unit
	slot7 = "Spine1"
	self._obj_spine = unit.get_object(slot3, Idstring(0.5))
	slot4 = unit
	self._m_rot = unit.rotation(slot3)
	self._footstep_style = nil
	self._footstep_event = ""
	slot4 = unit
	slot7 = "Hips"
	self._obj_com = unit.get_object(slot3, Idstring(0.5))
	slot5 = "AI_graph_obstacle_check"
	self._slotmask_gnd_ray = managers.slot.get_mask(slot3, managers.slot)
	slot2 = self._action_variants
	slot5 = self._unit

	if not self._unit.movement(managers.slot)._action_variant then
		slot5 = self._unit
		slot3 = self._unit.base(slot4)._tweak_table
	end

	self._actions = slot2[slot3]
	self._active_actions = {
		false,
		false,
		false,
		false
	}
	self._queued_actions = {}
	self._need_upd = true
	self._cool = true
	self._suppression = {
		value = 0
	}

	return 
end
CopMovement.post_init = function (self)
	local unit = self._unit
	slot4 = unit
	self._ext_brain = unit.brain(slot3)
	slot4 = unit
	self._ext_network = unit.network(slot3)
	slot4 = unit
	self._ext_anim = unit.anim_data(slot3)
	slot4 = unit
	self._ext_base = unit.base(slot3)
	slot4 = unit
	self._ext_damage = unit.character_damage(slot3)
	slot4 = unit
	self._ext_inventory = unit.inventory(slot3)
	self._tweak_data = tweak_data.character[self._ext_base._tweak_table]
	slot6 = self.tweak_data_clbk_reload

	tweak_data.add_reload_callback(self._ext_base._tweak_table, tweak_data, self)

	slot4 = self._unit
	self._machine = self._unit.anim_state_machine(self._ext_base._tweak_table)
	slot5 = self

	self._machine.set_callback_object(self._ext_base._tweak_table, self._machine)

	self._stance = {
		name = "ntl",
		code = 1,
		values = {
			1,
			0,
			0,
			0
		}
	}
	slot4 = managers.navigation

	if managers.navigation.is_data_ready() then
		slot5 = self._m_pos
		self._nav_tracker = managers.navigation.create_nav_tracker(slot3, managers.navigation)
		slot4 = managers.navigation
		self._pos_rsrv_id = managers.navigation.get_pos_reservation_id(slot3)
	else
		slot5 = "[CopMovement:post_init] Spawned AI unit with incomplete navigation data."

		Application.error(slot3, Application)

		slot6 = false

		self._unit.set_extension_update(slot3, self._unit, ids_movement)
	end

	slot4 = self._unit

	self._unit.kill_mover(slot3)

	slot5 = "script"

	self._unit.set_driving(slot3, self._unit)

	slot4 = self._unit
	self._unit.unit_data(slot3).has_alarm_pager = self._tweak_data.has_alarm_pager
	slot4 = self._unit
	slot6 = {
		"bleedout",
		"light_hurt",
		"heavy_hurt",
		"expl_hurt",
		"hurt",
		"hurt_sick",
		"shield_knock",
		"counter_tased",
		"taser_tased",
		"death",
		"fatal",
		"fire_hurt",
		"poison_hurt"
	}
	slot11 = "damage_clbk"

	self._unit.character_damage(self._tweak_data.has_alarm_pager).add_listener(self._tweak_data.has_alarm_pager, self._unit.character_damage(self._tweak_data.has_alarm_pager), "movement", callback(slot8, self, self))

	slot4 = self._unit
	slot6 = {
		"equip",
		"unequip"
	}
	slot11 = "clbk_inventory"

	self._unit.inventory(self._tweak_data.has_alarm_pager).add_listener(self._tweak_data.has_alarm_pager, self._unit.inventory(self._tweak_data.has_alarm_pager), "movement", callback(slot8, self, self))

	slot5 = "primary"
	local prim_weap_name = self._ext_base.default_weapon_name(self._tweak_data.has_alarm_pager, self._ext_base)
	slot6 = "secondary"
	local sec_weap_name = self._ext_base.default_weapon_name(self._ext_base, self._ext_base)

	if prim_weap_name then
		slot6 = self._unit
		slot7 = prim_weap_name

		self._unit.inventory(slot5).add_unit_by_name(slot5, self._unit.inventory(slot5))
	end

	if sec_weap_name and sec_weap_name ~= prim_weap_name then
		slot6 = self._unit
		slot7 = sec_weap_name

		self._unit.inventory(slot5).add_unit_by_name(slot5, self._unit.inventory(slot5))
	end

	slot6 = self._unit
	slot7 = 2

	if self._unit.inventory(slot5).is_selection_available(slot5, self._unit.inventory(slot5)) then
		slot6 = managers.groupai
		slot6 = managers.groupai.state(slot5)
	else
		slot6 = self._unit
		slot7 = 1

		if self._unit.inventory(slot5).is_selection_available(slot5, self._unit.inventory(slot5)) then
			slot6 = self._unit
			slot8 = true

			self._unit.inventory(slot5).equip_selection(slot5, self._unit.inventory(slot5), 1)
		end
	end

	slot6 = self._ext_inventory

	if self._ext_inventory.equipped_selection(slot5) == 1 then
		slot6 = managers.groupai
		slot6 = managers.groupai.state(slot5)

		if managers.groupai.state(slot5).whisper_mode(slot5) then
			slot7 = false

			self._ext_inventory.set_weapon_enabled(slot5, self._ext_inventory)
		end
	end

	slot9 = managers.groupai
	slot9 = managers.groupai.state(slot8)
	slot7 = (managers.groupai.state(slot8).enemy_weapons_hot(slot8) and "primary") or "secondary"
	local weap_name = self._ext_base.default_weapon_name(slot5, self._ext_base)
	slot7 = self._m_rot
	local fwd = self._m_rot.y(self._ext_base)
	slot9 = self._m_rot
	slot9 = fwd
	self._action_common_data = {
		stance = self._stance,
		pos = self._m_pos,
		rot = self._m_rot,
		fwd = fwd,
		right = self._m_rot.x(slot8),
		unit = unit,
		machine = self._machine,
		ext_movement = self,
		ext_brain = self._ext_brain,
		ext_anim = self._ext_anim,
		ext_inventory = self._ext_inventory,
		ext_base = self._ext_base,
		ext_network = self._ext_network,
		ext_damage = self._ext_damage,
		char_tweak = self._tweak_data,
		nav_tracker = self._nav_tracker,
		active_actions = self._active_actions,
		queued_actions = self._queued_actions,
		look_vec = mvector3.copy(self)
	}
	self._post_init_running = true

	self.upd_ground_ray(mvector3.copy(self))

	self._post_init_running = nil

	if self._gnd_ray then
		slot9 = self._gnd_ray.position

		self.set_position(slot7, self)
	end

	slot8 = self

	self._post_init(slot7)

	return 
end
CopMovement._post_init = function (self)
	slot3 = self

	self.set_character_anim_variables(slot2)

	slot3 = Network

	if Network.is_server(slot2) then
		slot3 = managers.groupai
		slot3 = managers.groupai.state(slot2)

		if not managers.groupai.state(slot2).whisper_mode(slot2) then
			slot4 = false

			self.set_cool(slot2, self)
		else
			slot4 = true

			self.set_cool(slot2, self)
		end

		slot3 = self._unit
		slot4 = self._cool

		self._unit.brain(slot2).on_cool_state_changed(slot2, self._unit.brain(slot2))
	end

	return 
end
CopMovement.set_character_anim_variables = function (self)
	if self._anim_global then
		slot5 = 1

		self._machine.set_global(slot2, self._machine, self._anim_global)
	end

	if self._tweak_data.female then
		slot5 = 1

		self._machine.set_global(slot2, self._machine, "female")
	end

	if self._tweak_data.allowed_stances and not self._tweak_data.allowed_stances.ntl then
		slot4 = false

		self.set_cool(slot2, self)

		if self._tweak_data.allowed_stances.hos then
			slot4 = 2

			self._change_stance(slot2, self)
		else
			slot4 = 3

			self._change_stance(slot2, self)
		end
	end

	if self._tweak_data.allowed_poses and not self._tweak_data.allowed_poses.stand then
		slot4 = "crouch"

		self.play_redirect(slot2, self)
	end

	return 
end
CopMovement.nav_tracker = function (self)
	return self._nav_tracker
end
CopMovement.warp_to = function (self, pos, rot)
	slot7 = pos

	self._unit.warp_to(slot4, self._unit, rot)

	return 
end
CopMovement.update = function (self, unit, t, dt)
	slot6 = managers.navigation

	if not managers.navigation.is_streamed_data_ready(slot5) then
		return 
	end

	slot6 = managers.network

	if managers.network.session(slot5) then
		slot6 = managers.network
		slot6 = managers.network.session(slot5)
		slot6 = managers.network.session(slot5).local_peer(slot5)

		if not managers.network.session(slot5).local_peer(slot5).loaded(slot5) then
			slot6 = Application

			if not Application.editor(slot5) then
				return 
			end
		end
	end

	if self._wait_load then
		return 
	end

	self._gnd_ray = nil
	local old_need_upd = self._need_upd
	self._need_upd = false
	slot8 = t

	self._upd_actions(slot6, self)

	if self._need_upd ~= old_need_upd then
		slot9 = self._need_upd

		unit.set_extension_update_enabled(slot6, unit, ids_movement)
	end

	if self._force_head_upd then
		self._force_head_upd = nil
		slot7 = self

		self.upd_m_head_pos(slot6)
	end

	return 
end
CopMovement._upd_actions = function (self, t)
	local a_actions = self._active_actions
	local has_no_action = true
	slot6 = a_actions

	for i_action, action in ipairs(slot5) do
		if action then
			if action.update then
				slot12 = t

				action.update(slot10, action)
			end

			if not self._need_upd and action.need_upd then
				slot11 = action
				self._need_upd = action.need_upd(slot10)
			end

			if action.expired then
				slot11 = action
			else
				has_no_action = nil
			end
		end
	end

	if has_no_action then
	end

	if not a_actions[1] and not a_actions[2] then
	end

	slot7 = t

	self._upd_stance(slot5, self)

	if not self._need_upd and (self._ext_anim.base_need_upd or self._ext_anim.upper_need_upd or self._stance.transition or self._suppression.transition or self._ext_anim.panic) then
		self._need_upd = true
	end

	return 
end
CopMovement._upd_stance = function (self, t)
	if self._stance.transition then
		local stance = self._stance
		local transition = stance.transition

		if transition.next_upd_t < t then
			local values = stance.values
			local prog = (t - transition.start_t) / transition.duration

			if prog < 1 then
				slot10 = 1
				local prog_smooth = math.clamp(slot7, math.bezier(slot9, stance_ctl_pts), 0)
				local v_start = transition.start_values
				local v_end = transition.end_values
				local mlerp = math.lerp
				slot12 = v_start

				for i, v in ipairs(prog) do
					slot19 = prog_smooth
					values[i] = mlerp(slot16, v, v_end[i])
				end

				transition.next_upd_t = t + 0.033
			else
				slot8 = transition.end_values

				for i, v in ipairs(slot7) do
					values[i] = v
				end

				stance.transition = nil
			end

			local names = CopMovement._stance.names
			slot9 = values

			for i, v in ipairs(slot8) do
				slot16 = v

				self._machine.set_global(slot13, self._machine, names[i])
			end
		end
	end

	if self._suppression.transition then
		local suppression = self._suppression
		local transition = suppression.transition

		if transition.next_upd_t < t then
			local prog = (t - transition.start_t) / transition.duration

			if prog < 1 then
				slot10 = prog
				slot9 = 1
				local prog_smooth = math.clamp(slot6, math.bezier(slot8, stance_ctl_pts), 0)
				slot10 = prog_smooth
				local val = math.lerp(math.bezier(slot8, stance_ctl_pts), transition.start_val, transition.end_val)
				suppression.value = val
				slot11 = val

				self._machine.set_global(transition.start_val, self._machine, "sup")

				transition.next_upd_t = t + 0.033
			else
				slot9 = transition.end_val

				self._machine.set_global(slot6, self._machine, "sup")

				suppression.value = transition.end_val
				suppression.transition = nil
			end
		end
	end

	return 
end
CopMovement.on_anim_freeze = function (self, state)
	self._frozen = state

	return 
end
CopMovement.upd_m_head_pos = function (self)
	slot4 = self._m_head_pos

	self._obj_head.m_position(slot2, self._obj_head)

	slot4 = self._m_com

	self._obj_spine.m_position(slot2, self._obj_spine)

	return 
end
CopMovement.set_position = function (self, pos)
	slot5 = pos

	mvec3_set(slot3, self._m_pos)

	slot5 = pos

	mvec3_set(slot3, self._m_stand_pos)

	slot5 = pos.z + 160

	mvec3_set_z(slot3, self._m_stand_pos)

	slot5 = self._m_head_pos

	self._obj_head.m_position(slot3, self._obj_head)

	slot5 = self._m_com

	self._obj_spine.m_position(slot3, self._obj_spine)

	slot5 = pos

	self._nav_tracker.move(slot3, self._nav_tracker)

	slot5 = pos

	self._unit.set_position(slot3, self._unit)

	return 
end
CopMovement.set_m_pos = function (self, pos)
	slot5 = pos

	mvec3_set(slot3, self._m_pos)

	slot5 = pos

	mvec3_set(slot3, self._m_stand_pos)

	slot5 = pos.z + 160

	mvec3_set_z(slot3, self._m_stand_pos)

	slot5 = self._m_head_pos

	self._obj_head.m_position(slot3, self._obj_head)

	slot5 = pos

	self._nav_tracker.move(slot3, self._nav_tracker)

	slot5 = self._m_com

	self._obj_spine.m_position(slot3, self._obj_spine)

	return 
end
CopMovement.set_m_rot = function (self, rot)
	slot7 = rot
	slot7 = 0

	mrot_set(slot3, self._m_rot, rot.yaw(slot6), 0)

	slot5 = rot
	self._action_common_data.fwd = rot.y(self._m_rot)
	slot5 = rot
	self._action_common_data.right = rot.x(self._m_rot)

	return 
end
CopMovement.set_rotation = function (self, rot)
	slot7 = rot
	slot7 = 0

	mrot_set(slot3, self._m_rot, rot.yaw(slot6), 0)

	slot5 = rot
	self._action_common_data.fwd = rot.y(self._m_rot)
	slot5 = rot
	self._action_common_data.right = rot.x(self._m_rot)
	slot5 = rot

	self._unit.set_rotation(rot.x(self._m_rot), self._unit)

	return 
end
CopMovement.m_pos = function (self)
	return self._m_pos
end
CopMovement.m_stand_pos = function (self)
	return self._m_stand_pos
end
CopMovement.m_com = function (self)
	return self._m_com
end
CopMovement.m_head_pos = function (self)
	return self._m_head_pos
end
CopMovement.m_head_rot = function (self)
	slot3 = self._obj_head

	return self._obj_head.rotation(slot2)
end
CopMovement.m_fwd = function (self)
	return self._action_common_data.fwd
end
CopMovement.m_rot = function (self)
	return self._m_rot
end
CopMovement.get_object = function (self, object_name)
	if self._unit == nil then
		return nil
	end

	slot4 = self._unit

	if not alive(slot3) then
		return nil
	end

	slot5 = object_name

	return self._unit.get_object(slot3, self._unit)
end
CopMovement.set_m_host_stop_pos = function (self, pos)
	if not self._m_host_stop_pos then
		slot6 = 0
		slot2 = Vector3(slot3, 0, 0)
	end

	self._m_host_stop_pos = slot2

	if not pos then
		return 
	end

	slot5 = pos

	mvec3_set(slot3, self._m_host_stop_pos)

	return 
end
CopMovement.m_host_stop_pos = function (self)
	return self._m_host_stop_pos
end
CopMovement.play_redirect = function (self, redirect_name, at_time)
	slot8 = redirect_name
	local result = self._unit.play_redirect(slot4, self._unit, Idstring(at_time))
	slot6 = ""

	return result ~= Idstring(self._unit) and result
end
CopMovement.play_state = function (self, state_name, at_time)
	slot8 = state_name
	local result = self._unit.play_state(slot4, self._unit, Idstring(at_time))
	slot6 = ""

	return result ~= Idstring(self._unit) and result
end
CopMovement.play_state_idstr = function (self, state_name, at_time)
	slot7 = at_time
	local result = self._unit.play_state(slot4, self._unit, state_name)
	slot6 = ""

	return result ~= Idstring(self._unit) and result
end
CopMovement.set_root_blend = function (self, state)
	if state then
		if self._root_blend_ref == 1 then
			slot5 = true

			self._machine.set_root_blending(slot3, self._machine)
		end

		self._root_blend_ref = self._root_blend_ref - 1
	else
		if self._root_blend_ref == 0 then
			slot5 = false

			self._machine.set_root_blending(slot3, self._machine)
		end

		self._root_blend_ref = self._root_blend_ref + 1
	end

	return 
end
CopMovement.chk_action_forbidden = function (self, action_type)
	slot4 = self

	if self.is_parachuting(slot3) and action_type ~= "death" then
		return true
	end

	slot4 = TimerManager
	local t = TimerManager.game(slot3).time(slot3)
	slot5 = self._active_actions

	for i_action, action in ipairs(TimerManager.game(slot3)) do
		if action and action.chk_block then
			slot12 = t

			if action.chk_block(slot9, action, action_type) then
				return true
			end
		end
	end

	return 
end
CopMovement.action_request = function (self, action_desc)
	slot4 = Network

	if Network.is_server(slot3) and self._active_actions[1] then
		slot4 = self._active_actions[1]

		if self._active_actions[1].type(slot3) == "hurt" then
			slot4 = self._active_actions[1]

			if self._active_actions[1].hurt_type(slot3) == "death" then
				slot6 = self._unit
				slot9 = action_desc

				debug_pause_unit(slot3, self._unit, "[CopMovement:action_request] Dead man walking!!!", inspect(slot8))
			end
		end
	end

	self.has_no_action = nil
	local body_part = action_desc.body_part
	local active_actions = self._active_actions
	local interrupted_actions = nil

	local function _interrupt_action(body_part)
		local old_action = active_actions[body_part]

		if old_action then
			active_actions[body_part] = false

			if old_action.on_exit then
				slot4 = old_action

				old_action.on_exit(slot3)
			end

			interrupted_actions = interrupted_actions or {}
			interrupted_actions[body_part] = old_action
		end

		return 
	end

	slot8 = body_part

	_interrupt_action(slot7)

	if body_part == 1 then
		slot8 = 2

		_interrupt_action(slot7)

		slot8 = 3

		_interrupt_action(slot7)
	elseif body_part == 2 or body_part == 3 then
		slot8 = 1

		_interrupt_action(slot7)
	end

	if not self._actions[action_desc.type] then
		slot9 = inspect(slot10)
		slot12 = action_desc

		debug_pause(slot7, "[CopMovement:action_request] invalid action started", inspect(self._actions))

		return 
	end

	slot10 = self._action_common_data
	local action, success = self._actions[action_desc.type].new(action_desc.type, self._actions[action_desc.type], action_desc)

	if success then
	end

	if interrupted_actions then
		slot10 = interrupted_actions

		for body_part, interrupted_action in pairs(slot9) do
			slot16 = interrupted_action

			self._ext_brain.on_action_completed(slot14, self._ext_brain)
		end
	end

	slot10 = self._ext_base

	self._ext_base.chk_freeze_anims(slot9)

	return success and action
end
CopMovement.get_action = function (self, body_part)
	return self._active_actions[body_part]
end
CopMovement.set_attention = function (self, attention)
	if not attention and not self._attention then
		return 
	end

	if attention and self._attention then
		local different = nil
		slot5 = self._attention

		for i, k in pairs(slot4) do
			if attention[i] ~= k then
				different = true

				break
			end
		end

		if not different then
			slot5 = attention

			for i, k in pairs(slot4) do
				if self._attention[i] ~= k then
					different = true

					break
				end
			end
		end

		if not different then
			return 
		end
	end

	slot5 = self._attention

	self._remove_attention_destroy_listener(slot3, self)

	if attention then
		slot4 = self._unit
		slot4 = self._unit.character_damage(slot3)

		if self._unit.character_damage(slot3).dead(slot3) then
			slot6 = self._unit
			slot9 = attention

			debug_pause_unit(slot3, self._unit, "[CopMovement:set_attention] dead AI", inspect(slot8))
		end

		if attention.unit then
			local attention_unit = nil

			if attention.handler then
				local attention_unit = attention.handler.unit(slot4)
				slot6 = attention_unit

				if attention_unit.id(attention.handler) ~= -1 then
					slot9 = attention.reaction

					self._ext_network.send(slot5, self._ext_network, "set_attention", attention_unit)
				else
					slot7 = "cop_set_attention_pos"
					slot12 = attention.handler

					self._ext_network.send(slot5, self._ext_network, mvector3.copy(attention.handler.get_attention_m_pos(slot11)))
				end
			else
				local attention_unit = attention.unit
				slot6 = attention_unit

				if attention_unit.id(slot5) ~= -1 then
					slot9 = AIAttentionObject.REACT_IDLE

					self._ext_network.send(slot5, self._ext_network, "set_attention", attention_unit)
				end
			end

			slot6 = attention

			self._add_attention_destroy_listener(slot4, self)
		else
			slot6 = attention.pos

			self._ext_network.send(slot3, self._ext_network, "cop_set_attention_pos")
		end
	elseif self._attention then
		slot4 = self._unit

		if self._unit.id(slot3) ~= -1 then
			slot7 = AIAttentionObject.REACT_IDLE

			self._ext_network.send(slot3, self._ext_network, "set_attention", nil)
		end
	end

	local old_attention = self._attention
	self._attention = attention
	self._action_common_data.attention = attention
	slot5 = self._active_actions

	for _, action in ipairs(slot4) do
		if action and action.on_attention then
			slot12 = old_attention

			action.on_attention(slot9, action, attention)
		end
	end

	return 
end
CopMovement.set_stance = function (self, new_stance_name, instant, execute_queued)
	slot6 = CopMovement._stance.names

	for i_stance, stance_name in ipairs(slot5) do
		if stance_name == new_stance_name then
			slot14 = execute_queued

			self.set_stance_by_code(slot10, self, i_stance, instant)

			break
		end
	end

	return 
end
CopMovement.set_stance_by_code = function (self, new_stance_code, instant, execute_queued)
	if self._stance.code ~= new_stance_code then
		if new_stance_code == 1 then
			slot9 = new_stance_code

			Application.debug(slot5, Application, "CopMovement:set_stance_by_code", self._unit)
		end

		slot10 = execute_queued or false

		self._ext_network.send(slot5, self._ext_network, "set_stance", new_stance_code, instant or false)

		slot8 = instant

		self._change_stance(slot5, self, new_stance_code)
	end

	return 
end
CopMovement._change_stance = function (self, stance_code, instant)
	if self._tweak_data.allowed_stances then
		if stance_code == 1 and not self._tweak_data.allowed_stances.ntl then
			return 
		elseif stance_code == 2 and not self._tweak_data.allowed_stances.hos then
			return 
		elseif stance_code == 3 and not self._tweak_data.allowed_stances.cbt then
			return 
		end
	end

	local stance = self._stance

	if instant then
		if stance.transition or stance.code ~= stance_code then
			stance.transition = nil
			stance.code = stance_code
			stance.name = CopMovement._stance.names[stance_code]

			for i = 1, 3, 1 do
				stance.values[i] = 0
			end

			stance.values[stance_code] = 1
			slot6 = stance.values

			for i, v in ipairs(1) do
				slot13 = v

				self._machine.set_global(slot10, self._machine, CopMovement._stance.names[i])
			end
		end
	else
		local end_values = {}

		if stance_code == 4 then
			if stance.transition then
				end_values = stance.transition.end_values
			else
				slot7 = stance.values

				for i, value in ipairs(slot6) do
					end_values[i] = value
				end
			end
		elseif stance.transition then
			end_values = {
				0,
				0,
				0,
				stance.transition.end_values[4]
			}
		else
			end_values = {
				0,
				0,
				0,
				stance.values[4]
			}
		end

		end_values[stance_code] = 1

		if stance_code ~= 4 then
			stance.code = stance_code
			stance.name = CopMovement._stance.names[stance_code]
		end

		local delay = nil
		slot8 = self._ext_base
		local vis_state = self._ext_base.lod_stage(slot7)

		if vis_state then
			delay = CopMovement._stance.blend[stance_code]

			if 2 < vis_state then
				delay = delay * 0.5
			end
		else
			stance.transition = nil

			if stance_code ~= 1 then
				slot9 = self

				self._chk_play_equip_weapon(slot8)
			end

			local names = CopMovement._stance.names
			slot10 = end_values

			for i, v in ipairs(slot9) do
				if v ~= stance.values[i] then
					stance.values[i] = v
					slot17 = v

					self._machine.set_global(slot14, self._machine, names[i])
				end
			end

			return 
		end

		local start_values = {}
		slot10 = stance.values

		for _, value in ipairs(slot9) do
			slot16 = value

			table.insert(slot14, start_values)
		end

		slot10 = TimerManager
		slot10 = TimerManager.game(slot9)
		local t = TimerManager.game(slot9).time(slot9)
		local transition = {
			end_values = end_values,
			start_values = start_values,
			duration = delay,
			start_t = t,
			next_upd_t = t + 0.07
		}
		stance.transition = transition
	end

	if stance_code ~= 1 then
		slot6 = self

		self._chk_play_equip_weapon(slot5)
	end

	slot6 = self

	self.enable_update(slot5)

	return 
end
CopMovement.sync_stance = function (self, i_stance, instant, execute_queued)
	if execute_queued then
	end

	slot8 = instant

	self._change_stance(slot5, self, i_stance)

	if i_stance == 1 then
		slot7 = true

		self.set_cool(slot5, self)
	else
		slot7 = false

		self.set_cool(slot5, self)
	end

	return 
end
CopMovement.stance_name = function (self)
	return self._stance.name
end
CopMovement.stance_code = function (self)
	return self._stance.code
end
CopMovement._chk_play_equip_weapon = function (self)
	if self._stance.values[1] == 1 and not self._ext_anim.equip and not self._tweak_data.no_equip_anim then
		slot4 = "action"

		if not self.chk_action_forbidden(slot2, self) then
			slot4 = "equip"
			local redir_res = self.play_redirect(slot2, self)

			if redir_res then
				slot4 = self._ext_inventory
				local weapon_unit = self._ext_inventory.equipped_unit(slot3)

				if weapon_unit then
					slot5 = weapon_unit
					slot5 = weapon_unit.base(slot4)
					local weap_tweak = weapon_unit.base(slot4).weapon_tweak_data(slot4)
					local weapon_hold = weap_tweak.hold
					slot10 = 1

					self._machine.set_parameter(slot6, self._machine, redir_res, "to_" .. weapon_hold)
				end
			end
		end
	end

	slot4 = true

	self._ext_inventory.set_weapon_enabled(slot2, self._ext_inventory)

	return 
end
CopMovement.set_cool = function (self, state, giveaway)
	if state then
		state = true
	else
		state = false
	end

	if not state then
		slot5 = managers.groupai
		slot5 = managers.groupai.state(slot4)

		if not managers.groupai.state(slot4).enemy_weapons_hot(slot4) then
			slot5 = managers.groupai
			slot7 = giveaway
			self._coolness_giveaway = managers.groupai.state(slot4).fetch_highest_giveaway(slot4, managers.groupai.state(slot4), self._coolness_giveaway)
		end
	end

	if state == self._cool then
		return 
	end

	local old_state = self._cool
	self._cool = state
	self._action_common_data.is_cool = state

	if not state and old_state then
		slot6 = TimerManager
		slot6 = TimerManager.game(slot5)
		self._not_cool_t = TimerManager.game(slot5).time(slot5)
		slot6 = Network

		if Network.is_server(slot5) and self._stance.name == "ntl" then
			if not self._tweak_data.allowed_stances or self._tweak_data.allowed_stances.hos then
				self.set_stance(slot5, self, "hos", nil)
			elseif self._tweak_data.allowed_stances.cbt then
				self.set_stance(slot5, self, "cbt", nil)
			end
		end

		slot6 = self._unit

		if self._unit.unit_data(slot5).mission_element then
			slot6 = self._unit

			if not self._unit.unit_data(slot5).alerted_event_called then
				slot6 = self._unit
				self._unit.unit_data(slot5).alerted_event_called = true
				slot6 = self._unit
				slot8 = self._unit

				self._unit.unit_data(true).mission_element.event(true, self._unit.unit_data(true).mission_element, "alerted")
			end
		end

		slot6 = Network

		if Network.is_server(slot5) then
			slot6 = managers.groupai
			slot7 = self._unit

			if not managers.groupai.state(slot5).all_criminals(slot5)[self._unit.key(managers.groupai.state(slot5))] then
				slot6 = managers.groupai
				slot9 = true

				managers.groupai.state(slot5).on_criminal_suspicion_progress(slot5, managers.groupai.state(slot5), nil, self._unit)
			end
		end
	end

	slot6 = self._unit
	slot7 = state

	self._unit.brain(slot5).on_cool_state_changed(slot5, self._unit.brain(slot5))

	if not state and old_state then
		slot6 = self._unit

		if self._unit.unit_data(slot5).mission_element then
			slot6 = self._unit
			slot8 = self._unit

			self._unit.unit_data(slot5).mission_element.event(slot5, self._unit.unit_data(slot5).mission_element, "weapons_hot")
		end
	end

	return 
end
CopMovement.cool = function (self)
	return self._cool
end
CopMovement.coolness_giveaway = function (self)
	return self._coolness_giveaway
end
CopMovement.set_giveaway = function (self, giveaway)
	self._coolness_giveaway = giveaway

	return 
end
CopMovement.remove_giveaway = function (self)
	self._coolness_giveaway = false

	return 
end
CopMovement.not_cool_t = function (self)
	return self._not_cool_t
end
CopMovement.synch_attention = function (self, attention)
	if attention then
		slot4 = self._unit
		slot4 = self._unit.character_damage(slot3)

		if self._unit.character_damage(slot3).dead(slot3) then
			slot6 = self._unit
			slot9 = attention

			debug_pause_unit(slot3, self._unit, "[CopMovement:synch_attention] dead AI", inspect(slot8))
		end
	end

	slot5 = self._attention

	self._remove_attention_destroy_listener(slot3, self)

	slot5 = attention

	self._add_attention_destroy_listener(slot3, self)

	if attention and attention.unit and not attention.destroy_listener_key then
		slot6 = attention.unit

		debug_pause_unit(slot3, attention.unit, "[CopMovement:synch_attention] problematic attention unit")

		slot5 = nil

		self.synch_attention(slot3, self)

		return 
	end

	self._attention = attention
	self._action_common_data.attention = attention
	slot4 = self._active_actions

	for _, action in ipairs(slot3) do
		if action and action.on_attention then
			slot10 = attention

			action.on_attention(slot8, action)
		end
	end

	return 
end
CopMovement._add_attention_destroy_listener = function (self, attention)
	if attention and attention.unit then

		-- Decompilation error in this vicinity:
		slot4 = attention.unit

		if not listener_class then
			return 
		end

		slot8 = self._unit
		local listener_key = "CopMovement" .. tostring(self._unit.key(slot7))
		attention.destroy_listener_key = listener_key
		slot7 = listener_key
		slot12 = "attention_unit_destroy_clbk"

		listener_class.add_destroy_listener(slot5, listener_class, callback(slot9, self, self))

		slot6 = attention.unit
		attention.debug_unit_name = attention.unit.name(slot5)
	end

	return 
end
CopMovement._remove_attention_destroy_listener = function (self, attention)
	if attention and attention.destroy_listener_key then

		-- Decompilation error in this vicinity:
		slot4 = attention.unit

		if not alive(slot3) then
			slot6 = self._unit
			slot9 = attention

			debug_pause_unit(slot3, self._unit, "[CopDamage:_on_damage_received] dead AI", inspect(slot8))

			attention.destroy_listener_key = nil

			return 
		end

		slot4 = attention.unit
		slot6 = attention.destroy_listener_key

		listener_class.remove_destroy_listener(slot4, listener_class)

		attention.destroy_listener_key = nil
	end

	return 
end
CopMovement.attention = function (self)
	return self._attention
end
CopMovement.attention_unit_destroy_clbk = function (self, unit)
	slot4 = Network

	if Network.is_server(slot3) then
		slot4 = self

		self.set_attention(slot3)
	else
		slot4 = self

		self.synch_attention(slot3)
	end

	return 
end
CopMovement.set_allow_fire_on_client = function (self, state, unit)
	slot5 = Network

	if Network.is_server(slot4) then
		slot5 = unit
		slot6 = {
			"set_allow_fire",
			self._unit,
			state
		}

		unit.network(slot4).send_to_unit(slot4, unit.network(slot4))
	end

	return 
end
CopMovement.set_allow_fire = function (self, state)
	if self._allow_fire == state then
		return 
	end

	slot5 = state

	self.synch_allow_fire(slot3, self)

	slot4 = Network

	if Network.is_server(slot3) then
		slot6 = state

		self._ext_network.send(slot3, self._ext_network, "set_allow_fire")
	end

	slot4 = self

	self.enable_update(slot3)

	return 
end
CopMovement.synch_allow_fire = function (self, state)
	slot4 = self._active_actions

	for _, action in pairs(slot3) do
		if action and action.allow_fire_clbk then
			slot10 = state

			action.allow_fire_clbk(slot8, action)
		end
	end

	self._allow_fire = state
	self._action_common_data.allow_fire = state

	return 
end
CopMovement.linked = function (self, state, physical, parent_unit)
	if state then
		self._link_data = {
			physical = physical,
			parent = parent_unit
		}
		slot6 = parent_unit
		slot12 = self._unit
		slot7 = "CopMovement" .. tostring(self._unit.key(slot11))
		slot12 = "parent_clbk_unit_destroyed"

		parent_unit.base(slot5).add_destroy_listener(slot5, parent_unit.base(slot5), callback(slot9, self, self))
	else
		slot6 = parent_unit
		slot12 = self._unit
		slot7 = "CopMovement" .. tostring(self._unit.key(slot11))

		parent_unit.base(slot5).remove_destroy_listener(slot5, parent_unit.base(slot5))

		self._link_data = nil
	end

	return 
end
CopMovement.parent_clbk_unit_destroyed = function (self, parent_unit, key)
	self._link_data = nil
	slot5 = parent_unit
	slot11 = self._unit
	slot6 = "CopMovement" .. tostring(self._unit.key(slot10))

	parent_unit.base(slot4).remove_destroy_listener(slot4, parent_unit.base(slot4))

	return 
end
CopMovement.is_physically_linked = function (self)
	return self._link_data and self._link_data.physical
end
CopMovement.move_vec = function (self)
	return self._move_dir
end
CopMovement.upd_ground_ray = function (self, from_pos)
	slot4 = self._nav_tracker
	local ground_z = self._nav_tracker.field_z(slot3)
	local safe_pos = temp_vec1
	slot7 = from_pos or self._m_pos

	mvec3_set(slot5, temp_vec1)

	slot7 = ground_z + 100

	mvec3_set_z(slot5, temp_vec1)

	local down_pos = temp_vec2
	slot8 = safe_pos

	mvec3_set(temp_vec1, temp_vec2)

	slot8 = ground_z - tweak_data.player.PLAYER_EYE_HEIGHT

	mvec3_set_z(temp_vec1, temp_vec2)

	local old_pos = self._m_pos
	local new_pos = from_pos or self._m_pos
	local hit_ray = nil

	if old_pos.z == new_pos.z then
		slot17 = "walk"
		local gnd_ray_1 = World.raycast(slot9, World, "ray", temp_vec1, temp_vec2, "slot_mask", self._slotmask_gnd_ray, "ray_type")

		if gnd_ray_1 then
			slot13 = 0.5
			ground_z = math.lerp(slot10, gnd_ray_1.position.z, self._m_pos.z)
			hit_ray = gnd_ray_1
		elseif self._post_init_running then
			ground_z = new_pos.z
		end
	else
		slot17 = "walk"
		local gnd_ray_1 = World.raycast(slot9, World, "ray", temp_vec1, temp_vec2, "slot_mask", self._slotmask_gnd_ray, "ray_type")
		local move_vec = temp_vec3
		slot13 = new_pos

		mvec3_set("ray", move_vec)

		slot13 = old_pos

		mvector3.subtract("ray", move_vec)

		slot13 = 0

		mvec3_set_z("ray", move_vec)

		local move_vec_len = mvector3.normalize("ray")
		slot13 = move_vec
		slot17 = 20

		mvector3.multiply(move_vec, math.min(self._slotmask_gnd_ray, move_vec_len))

		slot14 = move_vec

		mvector3.add(move_vec, temp_vec1)

		slot14 = move_vec

		mvector3.add(move_vec, temp_vec2)

		if gnd_ray_1 then
			hit_ray = gnd_ray_1
			slot20 = "walk"
			local gnd_ray_2 = World.raycast(slot12, World, "ray", temp_vec1, temp_vec2, "slot_mask", self._slotmask_gnd_ray, "ray_type")

			if gnd_ray_2 then
				slot16 = 0.5
				ground_z = math.lerp(slot13, gnd_ray_1.position.z, gnd_ray_2.position.z)
			else
				slot16 = 0.5
				ground_z = math.lerp(slot13, gnd_ray_1.position.z, self._m_pos.z)
			end
		else
			slot20 = "walk"
			local gnd_ray_2 = World.raycast(slot12, World, "ray", temp_vec1, temp_vec2, "slot_mask", self._slotmask_gnd_ray, "ray_type")

			if gnd_ray_2 then
				hit_ray = gnd_ray_2
				slot16 = 0.5
				ground_z = math.lerp(slot13, gnd_ray_2.position.z, self._m_pos.z)
			end
		end
	end

	local fake_ray = {}
	slot12 = ground_z
	fake_ray.position = new_pos.with_z(slot10, new_pos)
	fake_ray.ray = math.DOWN
	fake_ray.unit = hit_ray and hit_ray.unit
	self._action_common_data.gnd_ray = fake_ray
	self._gnd_ray = fake_ray

	return 
end
CopMovement.on_suppressed = function (self, state)
	local suppression = self._suppression
	local end_value = (state and 1) or 0
	slot6 = self._ext_base
	local vis_state = self._ext_base.lod_stage(slot5)

	if vis_state and end_value ~= suppression.value then
		slot7 = TimerManager
		local t = TimerManager.game(slot6).time(slot6)
		slot8 = end_value - suppression.value
		local duration = 0.5 * math.abs(TimerManager.game(slot6))
		suppression.transition = {
			end_val = end_value,
			start_val = suppression.value,
			duration = duration,
			start_t = t,
			next_upd_t = t + 0.07
		}
	else
		suppression.transition = nil
		suppression.value = end_value
		slot9 = end_value

		self._machine.set_global(slot6, self._machine, "sup")
	end

	self._action_common_data.is_suppressed = (state and true) or nil
	slot7 = Network

	if Network.is_server(slot6) and state and (not self._tweak_data.allowed_poses or self._tweak_data.allowed_poses.crouch) and (not self._tweak_data.allowed_poses or self._tweak_data.allowed_poses.stand) then
		slot8 = "walk"

		if not self.chk_action_forbidden(slot6, self) then
			if state == "panic" then
				slot8 = "act"
			elseif self._ext_anim.idle then
			elseif not self._ext_anim.crouch and self._tweak_data.crouch_move and (not self._tweak_data.allowed_poses or self._tweak_data.allowed_poses.crouch) then
				local action_desc = {
					body_part = 4,
					type = "crouch"
				}
				slot9 = action_desc

				self.action_request(slot7, self)
			end
		end
	end

	slot7 = self

	self.enable_update(slot6)

	slot7 = Network

	if Network.is_server(slot6) then
		slot7 = managers.network
		slot10 = (state and true) or false

		managers.network.session(slot6).send_to_peers_synched(slot6, managers.network.session(slot6), "suppressed_state", self._unit)
	end

	return 
end
CopMovement.damage_clbk = function (self, my_unit, damage_info)

	-- Decompilation error in this vicinity:
	if damage_info.join_game then
		return 
	end

	slot5 = my_unit

	if my_unit.unit_data(slot4).turret_weapon and damage_info.result.type ~= "death" then
		return 
	end

	local hurt_type = damage_info.result.type
	local block_type = hurt_type

	if hurt_type == "expl_hurt" or hurt_type == "fire_hurt" or hurt_type == "poison_hurt" or hurt_type == "taser_tased" then
		block_type = "heavy_hurt"
	end

	if hurt_type == "death" and self._queued_actions then
		self._queued_actions = {}
	end

	if hurt_type == "death" then
		if self._rope then
			slot7 = self._rope
			slot7 = self._rope.base(slot6)

			self._rope.base(slot6).retract(slot6)

			self._rope = nil
		end

		slot7 = Network

		if Network.is_server(slot6) then
			slot7 = self

			self.set_attention(slot6)
		else
			slot7 = self

			self.synch_attention(slot6)
		end
	end

	local attack_dir = (damage_info.col_ray and damage_info.col_ray.ray) or damage_info.attack_dir
	local hit_pos = (damage_info.col_ray and damage_info.col_ray.position) or damage_info.pos
	local lgt_hurt = hurt_type == "light_hurt"
	local body_part = (lgt_hurt and 4) or 1
	local blocks = nil

	if not lgt_hurt then
		blocks = {
			act = -1,
			aim = -1,
			action = -1,
			tase = -1,
			walk = -1
		}

		if hurt_type == "bleedout" then
			blocks.bleedout = -1
			blocks.hurt = -1
			blocks.heavy_hurt = -1
			blocks.hurt_sick = -1
		end
	end

	if damage_info.variant == "tase" then
		block_type = "bleedout"
	elseif hurt_type == "expl_hurt" or hurt_type == "fire_hurt" or hurt_type == "poison_hurt" or hurt_type == "taser_tased" then
		block_type = "heavy_hurt"
	else
		block_type = hurt_type
	end

	local client_interrupt = nil
	slot13 = Network

	if Network.is_client(slot12) and (hurt_type == "light_hurt" or (hurt_type == "hurt" and damage_info.variant ~= "tase") or hurt_type == "heavy_hurt" or hurt_type == "expl_hurt" or hurt_type == "shield_knock" or hurt_type == "counter_tased" or hurt_type == "taser_tased" or hurt_type == "death" or hurt_type == "hurt_sick" or hurt_type == "fire_hurt" or hurt_type == "poison_hurt") then
		client_interrupt = true
	end

	local tweak = self._tweak_data
	local action_data = {
		type = "hurt",
		block_type = block_type,
		hurt_type = hurt_type,
		variant = damage_info.variant,
		direction_vec = attack_dir,
		hit_pos = hit_pos,
		body_part = body_part,
		blocks = blocks,
		client_interrupt = client_interrupt,
		attacker_unit = damage_info.attacker_unit,
		death_type = (tweak.damage.death_severity and ((tweak.damage.death_severity < damage_info.damage / tweak.HEALTH_INIT and "heavy") or "normal")) or "normal",
		ignite_character = damage_info.ignite_character,
		start_dot_damage_roll = damage_info.start_dot_damage_roll,
		is_fire_dot_damage = damage_info.is_fire_dot_damage,
		fire_dot_data = damage_info.fire_dot_data
	}
	slot15 = Network

	return 
end
CopMovement.anim_clbk_spawn_effect = function (self, unit, effect_name, object_name)
	slot6 = World
	slot7 = {
		effect = Idstring(slot9),
		parent = self._unit.get_object(slot9, Idstring(slot12))
	}
	slot10 = effect_name
	slot10 = self._unit
	slot13 = object_name

	World.effect_manager(slot5).spawn(slot5, World.effect_manager(slot5))

	return 
end
CopMovement.anim_clbk_footstep = function (self, unit)
	slot6 = self._m_pos

	managers.game_play_central.request_play_footstep(slot3, managers.game_play_central, unit)

	return 
end
CopMovement.get_footstep_event = function (self)
	local event_name = nil

	if self._footstep_style then
		slot4 = self._unit
	else
		slot4 = self._unit
		self._footstep_style = (self._unit.anim_data(slot3).run and "_run") or ""
		event_name = "footsteps_npc" .. self._footstep_style
		self._footstep_event = event_name
	end

	return event_name
end
CopMovement.get_walk_to_pos = function (self)
	local leg_action = self._active_actions[1] or self._active_actions[2]

	if leg_action and leg_action.get_walk_to_pos then
		slot4 = leg_action

		return leg_action.get_walk_to_pos(slot3)
	end

	return 
end
CopMovement.anim_clbk_death_drop = function (self, ...)
	slot3 = self._active_actions

	for _, action in ipairs(slot2) do
		if action and action.on_death_drop then
			slot8 = action

			action.on_death_drop(slot7, ...)
		end
	end

	return 
end
CopMovement.on_death_exit = function (self)
	slot3 = self._active_actions

	for _, action in ipairs(slot2) do
		if action and action.on_death_exit then
			slot8 = action

			action.on_death_exit(slot7)
		end
	end

	return 
end
CopMovement.anim_clbk_reload_exit = function (self)
	slot3 = self._ext_inventory

	if self._ext_inventory.equipped_unit(slot2) then
		slot3 = self._ext_inventory
		slot3 = self._ext_inventory.equipped_unit(slot2)
		slot3 = self._ext_inventory.equipped_unit(slot2).base(slot2)

		self._ext_inventory.equipped_unit(slot2).base(slot2).on_reload(slot2)
	end

	return 
end
CopMovement.anim_clbk_force_ragdoll = function (self)
	slot3 = self._active_actions

	for _, action in ipairs(slot2) do
		if action and action.force_ragdoll then
			slot8 = action

			action.force_ragdoll(slot7)
		end
	end

	return 
end
CopMovement.anim_clbk_rope = function (self, unit, state)
	if state == "on" then
		if self._rope then
			slot5 = self._rope
			slot5 = self._rope.base(slot4)

			self._rope.base(slot4).retract(slot4)
		end

		local hips_obj = self._unit.get_object(slot4, Idstring(slot7))
		slot10 = hips_obj
		slot8 = hips_obj.position("units/vanilla/dev/enemy_spawn_rope/enemy_spawn_rope")
		self._rope = World.spawn_unit(self._unit, World, Idstring("Hips"), Rotation())
		slot6 = self._rope
		slot7 = hips_obj

		self._rope.base(self._unit).setup(self._unit, self._rope.base(self._unit))
	elseif self._rope then
		slot5 = self._rope
		slot5 = self._rope.base(slot4)

		self._rope.base(slot4).retract(slot4)

		self._rope = nil
	end

	return 
end
CopMovement.rope_unit = function (self)
	return self._rope
end
CopMovement.pos_rsrv_id = function (self)
	return self._pos_rsrv_id
end
CopMovement.anim_clbk_melee_strike = function (self, unit)
	slot4 = self._active_actions

	for body_part, action in pairs(slot3) do
		if action and action.anim_clbk_melee_strike then
			slot9 = action

			action.anim_clbk_melee_strike(slot8)
		end
	end

	return 
end
CopMovement.anim_clbk_set_visibility = function (self, unit, state)
	if state == true then
		state = true
	else
		state = false
	end

	slot6 = state

	self._unit.set_visible(slot4, self._unit)

	return 
end
CopMovement.anim_clbk_wanted_item = function (self, unit, item_type, align_place, droppable)
	self._wanted_items = self._wanted_items or {}
	slot8 = {
		item_type,
		align_place,
		droppable
	}

	table.insert(slot6, self._wanted_items)

	return 
end
CopMovement.anim_clbk_block_info = function (self, unit, preset_name, block_state)
	local state_bool = (block_state == "true" and true) or false
	slot7 = self._active_actions

	for body_part, action in pairs(slot6) do
		if action and action.set_blocks then
			slot14 = state_bool

			action.set_blocks(slot11, action, preset_name)
		end
	end

	return 
end
CopMovement.anim_clbk_ik_change = function (self, unit)
	local preset_name = self._ext_anim.base_aim_ik
	slot5 = self._active_actions

	for body_part, action in pairs(slot4) do
		if action and action.set_ik_preset then
			slot11 = preset_name

			action.set_ik_preset(slot9, action)
		end
	end

	return 
end
CopMovement.anim_clbk_enter_vehicle = function (self, unit)
	if self.vehicle_unit and self.vehicle_seat then
		slot4 = self.vehicle_unit
		slot5 = self._unit

		self.vehicle_unit.vehicle_driving(slot3).on_team_ai_enter(slot3, self.vehicle_unit.vehicle_driving(slot3))
	else
		slot7 = self.vehicle_unit

		Application.debug(slot3, Application, "[CopMovement:anim_clbk_enter_vehicle] No seat present!", self._unit)
	end

	return 
end
CopMovement.anim_clbk_police_called = function (self, unit)
	slot4 = Network

	if Network.is_server(slot3) then
		slot4 = managers.groupai
		slot5 = "call"

		if not managers.groupai.state(slot3).is_ecm_jammer_active(slot3, managers.groupai.state(slot3)) then
			local group_state = managers.groupai.state(slot3)
			local cop_type = tostring(managers.groupai)
			slot6 = managers.groupai
			slot9 = "called"

			managers.groupai.state(group_state.blame_triggers[self._ext_base._tweak_table]).on_criminal_suspicion_progress(group_state.blame_triggers[self._ext_base._tweak_table], managers.groupai.state(group_state.blame_triggers[self._ext_base._tweak_table]), nil, self._unit)

			if cop_type == "civ" then
				slot6 = group_state
				slot9 = self

				group_state.on_police_called(slot5, self.coolness_giveaway(slot8))
			else
				slot6 = group_state
				slot9 = self

				group_state.on_police_called(slot5, self.coolness_giveaway(slot8))
			end
		else
			slot4 = managers.groupai
			slot7 = "call_interrupted"

			managers.groupai.state(slot3).on_criminal_suspicion_progress(slot3, managers.groupai.state(slot3), nil, self._unit)
		end
	end

	return 
end
CopMovement.anim_clbk_stance = function (self, unit, stance_name, instant)
	slot8 = instant

	self.set_stance(slot5, self, stance_name)

	return 
end
CopMovement.spawn_wanted_items = function (self)
	if self._wanted_items then
		slot3 = self._wanted_items

		for _, spawn_info in ipairs(slot2) do
			slot8 = self
			slot11 = spawn_info

			self._equip_item(slot7, unpack(slot10))
		end

		self._wanted_items = nil
	end

	return 
end
CopMovement._equip_item = function (self, item_type, align_place, droppable)
	local align_name = self._gadgets.aligns[align_place]

	if not align_name then
		slot8 = align_place

		print(slot6, "[CopMovement:anim_clbk_equip_item] non existent align place:")

		return 
	end

	slot8 = align_name
	local align_obj = self._unit.get_object(slot6, self._unit)
	local available_items = self._gadgets[item_type]

	if not available_items then
		slot10 = item_type

		print(slot8, "[CopMovement:anim_clbk_equip_item] non existent item_type:")

		return 
	end

	local item_name = available_items[math.random(slot8)]
	slot11 = item_name

	print(available_items, "[CopMovement:_equip_item]")

	slot12 = align_obj.position(slot13)
	local item_unit = World.spawn_unit(available_items, World, item_name, align_obj.rotation(align_obj))
	slot13 = item_unit
	slot16 = item_unit
	slot16 = item_unit.orientation_object(align_obj)

	self._unit.link(World, self._unit, align_name, item_unit.orientation_object(align_obj).name(align_obj))

	self._equipped_gadgets = self._equipped_gadgets or {}
	self._equipped_gadgets[align_place] = self._equipped_gadgets[align_place] or {}
	slot12 = item_unit

	table.insert(self._equipped_gadgets[align_place] or , self._equipped_gadgets[align_place])

	if droppable then
		self._droppable_gadgets = self._droppable_gadgets or {}
		slot12 = item_unit

		table.insert(slot10, self._droppable_gadgets)
	end

	return 
end
CopMovement.anim_clbk_drop_held_items = function (self)
	slot3 = self

	self.drop_held_items(slot2)

	return 
end
CopMovement.anim_clbk_flush_wanted_items = function (self)
	self._wanted_items = nil

	return 
end
CopMovement.drop_held_items = function (self)
	if not self._droppable_gadgets then
		return 
	end

	slot3 = self._droppable_gadgets

	for _, drop_item_unit in ipairs(slot2) do
		local wanted_item_key = drop_item_unit.key(slot7)
		slot9 = drop_item_unit

		if alive(drop_item_unit) then
			slot9 = self._equipped_gadgets

			for align_place, item_list in pairs(slot8) do
				if wanted_item_key then
					slot14 = item_list

					for i_item, item_unit in ipairs(slot13) do
						slot19 = item_unit

						if item_unit.key(slot18) == wanted_item_key then
							slot20 = i_item

							table.remove(slot18, item_list)

							wanted_item_key = nil

							break
						end
					end
				else
					break
				end
			end

			slot9 = drop_item_unit

			drop_item_unit.unlink(slot8)

			slot10 = 0

			drop_item_unit.set_slot(slot8, drop_item_unit)
		else
			slot9 = self._equipped_gadgets

			for align_place, item_list in pairs(slot8) do
				if wanted_item_key then
					slot14 = item_list

					for i_item, item_unit in ipairs(slot13) do
						slot19 = item_unit

						if not alive(slot18) then
							slot20 = i_item

							table.remove(slot18, item_list)
						end
					end
				end
			end
		end
	end

	self._droppable_gadgets = nil

	return 
end
CopMovement._destroy_gadgets = function (self)
	if not self._equipped_gadgets then
		return 
	end

	slot3 = self._equipped_gadgets

	for align_place, item_list in pairs(slot2) do
		slot8 = item_list

		for _, item_unit in ipairs(slot7) do
			slot13 = item_unit

			if alive(slot12) then
				slot14 = 0

				item_unit.set_slot(slot12, item_unit)
			end
		end
	end

	self._equipped_gadgets = nil
	self._droppable_gadgets = nil

	return 
end
CopMovement.anim_clbk_enemy_spawn_melee_item = function (self)
	slot3 = self._melee_item_unit

	if alive(slot2) then
		return 
	end

	local align_obj_l_name = CopMovement._gadgets.aligns.hand_l
	local align_obj_r_name = CopMovement._gadgets.aligns.hand_r
	slot6 = align_obj_l_name
	local align_obj_l = self._unit.get_object(slot4, self._unit)
	slot7 = align_obj_r_name
	local align_obj_r = self._unit.get_object(self._unit, self._unit)
	slot7 = self._unit
	slot7 = self._unit.base(self._unit)
	local melee_weapon = self._unit.base(self._unit).melee_weapon(self._unit)
	local unit_name = (melee_weapon and tweak_data.weapon.npc_melee[melee_weapon].unit_name) or nil

	if unit_name then
		slot14 = align_obj_l
		self._melee_item_unit = World.spawn_unit(slot8, World, unit_name, align_obj_l.rotation(align_obj_l))
		slot11 = self._melee_item_unit
		slot14 = self._melee_item_unit
		slot14 = self._melee_item_unit.orientation_object(align_obj_l)

		self._unit.link(slot8, self._unit, align_obj_l.name(align_obj_l.position(align_obj_l)), self._melee_item_unit.orientation_object(align_obj_l).name(align_obj_l))
	end

	return 
end
CopMovement.anim_clbk_enemy_unspawn_melee_item = function (self)
	slot3 = self._melee_item_unit

	if alive(slot2) then
		slot3 = self._melee_item_unit

		self._melee_item_unit.unlink(slot2)

		slot4 = self._melee_item_unit

		World.delete_unit(slot2, World)

		self._melee_item_unit = nil
	end

	return 
end
CopMovement.clbk_inventory = function (self, unit, event)
	slot5 = self._ext_inventory
	local weapon = self._ext_inventory.equipped_unit(slot4)

	if weapon then
		if self._weapon_hold then
			slot8 = 0

			self._machine.set_global(slot5, self._machine, self._weapon_hold)
		end

		if self._weapon_anim_global then
			slot8 = 0

			self._machine.set_global(slot5, self._machine, self._weapon_anim_global)
		end

		slot6 = weapon
		slot6 = weapon.base(slot5)
		local weap_tweak = weapon.base(slot5).weapon_tweak_data(slot5)
		local weapon_hold = weap_tweak.hold
		slot10 = 1

		self._machine.set_global(slot7, self._machine, weapon_hold)

		self._weapon_hold = weapon_hold
		local weapon_usage = weap_tweak.usage_anim
		slot11 = 1

		self._machine.set_global(self._machine, self._machine, weapon_usage)

		self._weapon_anim_global = weapon_usage
	end

	slot6 = self._active_actions

	for _, action in ipairs(slot5) do
		if action and action.on_inventory_event then
			slot12 = event

			action.on_inventory_event(slot10, action)
		end
	end

	return 
end
CopMovement.sync_shot_blank = function (self, impact)
	slot4 = self._ext_inventory
	local equipped_weapon = self._ext_inventory.equipped_unit(slot3)

	if equipped_weapon then
		slot5 = equipped_weapon

		if equipped_weapon.base(slot4).fire_blank then
			local fire_dir = nil

			if self._attention then
				if self._attention.unit then
					slot6 = self._attention.unit
					slot7 = self
					fire_dir = self._attention.unit.movement(slot5).m_head_pos(slot5) - self.m_head_pos(self._attention.unit.movement(slot5))
					slot6 = fire_dir

					mvector3.normalize(self.m_head_pos(self._attention.unit.movement(slot5)))
				else
					slot7 = self
					fire_dir = self._attention.pos - self.m_head_pos(fire_dir)

					mvector3.normalize(self.m_head_pos(fire_dir))
				end
			else
				fire_dir = self._action_common_data.fwd
			end

			slot6 = equipped_weapon
			slot8 = impact

			equipped_weapon.base(slot5).fire_blank(slot5, equipped_weapon.base(slot5), fire_dir)
		end
	end

	return 
end
CopMovement.sync_taser_fire = function (self)
	local tase_action = self._active_actions[3]

	if tase_action then
		slot4 = tase_action

		if tase_action.type(slot3) == "tase" then
			slot4 = tase_action

			if not tase_action.expired(slot3) then
				slot4 = tase_action

				tase_action.fire_taser(slot3)
			end
		end
	end

	return 
end
CopMovement.save = function (self, save_data)
	slot4 = self._unit
	local ext_damage = self._unit.character_damage(slot3)
	local my_save_data = {}
	slot6 = ext_damage
	my_save_data.dead = ext_damage.dead(slot5)

	if self._stance.code ~= 1 then
		my_save_data.stance_code = self._stance.code
	end

	if self._stance.transition then
		if self._stance.transition.end_values[4] ~= 0 then
			my_save_data.stance_wnd = true
		end
	elseif self._stance.values[4] ~= 0 then
		my_save_data.stance_wnd = true
	end

	slot6 = self._active_actions

	for _, action in ipairs(slot5) do
		if action and action.save then
			local action_save_data = {}
			slot13 = action_save_data

			action.save(slot11, action)

			slot12 = action_save_data

			if next(slot11) then
				my_save_data.actions = my_save_data.actions or {}
				slot13 = action_save_data

				table.insert(slot11, my_save_data.actions)
			end
		end
	end

	slot6 = ext_damage

	if not ext_damage.dead(slot5) and self._attention then
		if self._attention.pos then
			my_save_data.attention = self._attention
		else
			slot6 = self._attention.unit

			if self._attention.unit.id(slot5) == -1 then
				my_save_data.attention = {
					pos = attention_pos
				}
			else
				slot12 = self._unit
				slot13 = self._attention
				slot11 = TimerManager

				managers.enemy.add_delayed_clbk(slot5, managers.enemy, "clbk_sync_attention" .. tostring(self._unit.key(TimerManager.game(self))), callback(TimerManager.game(self).time(self) + 0.1, self, self, "clbk_sync_attention"))
			end
		end
	end

	if self._allow_fire then
		my_save_data.allow_fire = true
	end

	my_save_data.team_id = self._team.id

	if self._equipped_gadgets then

		-- Decompilation error in this vicinity:
		local equipped_items = {}
		my_save_data.equipped_gadgets = equipped_items

		local function _get_item_type_from_unit(item_unit)
			local wanted_item_name = item_unit.name(slot2)
			slot4 = self._gadgets

			for item_type, item_unit_names in pairs(item_unit) do
				slot9 = item_unit_names

				for i_item_unit_name, item_unit_name in ipairs(slot8) do
					if item_unit_name == wanted_item_name then
						return item_type
					end
				end
			end

			return 
		end

		local function _is_item_droppable(item_unit)
			if not self._droppable_gadgets then
				return 
			end

			local wanted_item_key = item_unit.key(slot2)
			slot4 = self._droppable_gadgets

			for _, droppable_unit in ipairs(item_unit) do
				slot9 = droppable_unit

				if droppable_unit.key(slot8) == wanted_item_key then
					return true
				end
			end

			return 
		end

		slot9 = self._equipped_gadgets

		for align_place, item_list in pairs(slot8) do
			slot14 = item_list

			for i_item, item_unit in ipairs(slot13) do
				slot19 = item_unit

				if alive(slot18) then
					slot20 = {
						_get_item_type_from_unit(slot22),
						align_place,
						_is_item_droppable(slot22)
					}
					slot23 = item_unit
					slot23 = item_unit

					table.insert(slot18, equipped_items)
				end
			end
		end
	end

	if self.vehicle_unit then
		slot6 = self.vehicle_unit
		my_save_data.vehicle_unit_id = self.vehicle_unit.unit_data(slot5).unit_id
	end

	slot6 = my_save_data

	if next(slot5) then
		save_data.movement = my_save_data
	end

	return 
end
CopMovement.load = function (self, load_data)
	self._load_data = load_data
	slot4 = managers.navigation

	if managers.navigation.is_data_ready(slot3) then
		slot4 = self

		self._do_load(slot3)
	else
		slot5 = "[CopMovement:load] queueng cop movement load until navigation is ready"

		Application.debug(slot3, Application)

		slot7 = self._unit
		self._nav_ready_listener_key = "CopMovement" .. tostring(self._unit.key({
			"navigation_ready"
		}))
		slot11 = "_do_load"

		managers.navigation.add_listener(tostring(self._unit.key()), managers.navigation, self._nav_ready_listener_key, callback(slot8, self, self))

		self._wait_load = true
	end

	return 
end
CopMovement._do_load = function (self)
	local load_data = self._load_data
	self._wait_load = false
	local my_load_data = load_data.movement

	if not my_load_data then
		return 
	end

	slot6 = "idle"
	local res = self.play_redirect(slot4, self)

	if not res then
		slot10 = self._machine
		slot13 = "base"

		debug_pause_unit(slot5, self._unit, "[CopMovement:load] failed idle redirect in ", self._machine.segment_state(self._unit, Idstring(slot12)))
	end

	self._allow_fire = my_load_data.allow_fire
	self._action_common_data.allow_fire = my_load_data.allow_fire
	self._attention = my_load_data.attention

	if my_load_data.stance_code then
		slot7 = my_load_data.stance_code

		self._change_stance(slot5, self)

		if my_load_data.stance_code == 1 then
			slot7 = true

			self.set_cool(slot5, self)
		else
			slot7 = false

			self.set_cool(slot5, self)
		end
	end

	if my_load_data.stance_wnd then
		slot7 = 4

		self._change_stance(slot5, self)
	end

	if not my_load_data.dead then
		slot6 = managers.groupai
		slot7 = my_load_data.team_id
		self._team = managers.groupai.state(slot5).team_data(slot5, managers.groupai.state(slot5))
		slot6 = managers.groupai
		slot12 = self._unit
		slot8 = {
			"team_def"
		}
		slot13 = "clbk_team_def"

		managers.groupai.state(slot5).add_listener(slot5, managers.groupai.state(slot5), "CopMovement_team_def_" .. tostring(self._unit.key(slot11)), callback(self._unit.key, self, self))
	end

	if my_load_data.actions then
		slot6 = my_load_data.actions

		for _, action_load_data in ipairs(slot5) do
			slot12 = action_load_data

			self.action_request(slot10, self)
		end
	end

	if my_load_data.equipped_gadgets then
		slot6 = my_load_data.equipped_gadgets

		for _, item_desc in ipairs(slot5) do
			slot11 = self
			slot14 = item_desc

			self._equip_item(slot10, unpack(slot13))
		end
	end

	if self._nav_ready_listener_key then
		slot7 = self._nav_ready_listener_key

		managers.navigation.remove_listener(slot5, managers.navigation)
	end

	if my_load_data.vehicle_unit_id then
	end

	return 
end
CopMovement.set_vehicle_unit = function (self, unit)
	self.vehicle_unit = unit

	return 
end
CopMovement.clbk_team_def = function (self)
	slot3 = managers.groupai
	slot4 = self._team.id
	self._team = managers.groupai.state(slot2).team_data(slot2, managers.groupai.state(slot2))
	slot3 = managers.groupai
	slot9 = self._unit
	slot4 = "CopMovement_team_def_" .. tostring(self._unit.key(slot8))

	managers.groupai.state(slot2).remove_listener(slot2, managers.groupai.state(slot2))

	return 
end
CopMovement.tweak_data_clbk_reload = function (self)
	self._tweak_data = tweak_data.character[self._ext_base._tweak_table]
	self._action_common_data.char_tweak = self._tweak_data

	return 
end
CopMovement._chk_start_queued_action = function (self)
	local queued_actions = self._queued_actions
	slot4 = queued_actions

	while next(slot3) do
		local action_desc = queued_actions[1]
		slot6 = action_desc

		if self.chk_action_forbidden(slot4, self) then
			self._need_upd = true

			break
		elseif action_desc.type == "stance" then
			return 
		end

		slot6 = 1

		table.remove(slot4, queued_actions)

		slot6 = action_desc

		CopMovement.action_request(slot4, self)
	end

	return 
end
CopMovement._push_back_queued_action = function (self, action_desc)
	slot5 = action_desc

	table.insert(slot3, self._queued_actions)

	return 
end
CopMovement._push_front_queued_action = function (self, action_desc)
	slot6 = action_desc

	table.insert(slot3, self._queued_actions, 1)

	return 
end
CopMovement._cancel_latest_action = function (self, search_type, explicit)

	-- Decompilation error in this vicinity:
	for i = #self._queued_actions, 1, -1 do
		if self._queued_actions[i].type == search_type then
			slot10 = i

			table.remove(slot8, self._queued_actions)

			return 
		end
	end

	slot5 = self._active_actions

	for body_part, action in ipairs(slot4) do
		if action then
			slot10 = action

			if action.type(slot9) == search_type then
				self._active_actions[body_part] = false

				if action.on_exit then
					slot10 = action

					action.on_exit(slot9)
				end

				slot10 = self

				self._chk_start_queued_action(slot9)

				slot11 = action

				self._ext_brain.on_action_completed(slot9, self._ext_brain)

				return 
			end
		end
	end

	if explicit then
		slot10 = inspect(slot11)
		slot13 = self._active_actions

		debug_pause_unit(slot4, self._unit, "[CopMovement:_cancel_latest_action] no queued or ongoing ", search_type, "action", self._unit, inspect(self._queued_actions))
	end

	return 
end
CopMovement._get_latest_walk_action = function (self)
	for i = #self._queued_actions, 1, -1 do
		if self._queued_actions[i].type == "walk" and self._queued_actions[i].persistent then
			return self._queued_actions[i], true
		end
	end

	if self._active_actions[2] then
		slot3 = self._active_actions[2]

		if self._active_actions[2].type(slot2) == "walk" then
			return self._active_actions[2]
		end
	end

	slot6 = inspect(slot7)
	slot9 = self._active_actions

	print(slot2, self._unit, "[CopMovement:_get_latest_walk_action] no queued or ongoing walk action", self._unit, inspect(self._queued_actions))

	return 
end
CopMovement._get_latest_act_action = function (self)
	for i = #self._queued_actions, 1, -1 do
		if self._queued_actions[i].type == "act" and not self._queued_actions[i].host_expired then
			return self._queued_actions[i], true
		end
	end

	if self._active_actions[1] then
		slot3 = self._active_actions[1]

		if self._active_actions[1].type(slot2) == "act" then
			return self._active_actions[1]
		end
	end

	return 
end
CopMovement.sync_action_walk_nav_point = function (self, pos)
	slot4 = self
	local walk_action, is_queued = self._get_latest_walk_action(slot3)

	if is_queued then
		slot7 = pos

		table.insert(slot5, walk_action.nav_path)
	elseif walk_action then
		slot7 = pos

		walk_action.append_nav_point(slot5, walk_action)
	else
		slot9 = pos

		print(slot5, self._unit, "[CopMovement:sync_action_walk_nav_point] no walk action!!!", self._unit)
	end

	return 
end
CopMovement.sync_action_walk_nav_link = function (self, pos, rot, anim_index, from_idle)
	slot12 = anim_index
	local nav_link = self._actions.walk.synthesize_nav_link(slot6, pos, rot, self._actions.act._get_act_name_from_index(from_idle, self._actions.act))
	slot8 = self
	local walk_action, is_queued = self._get_latest_walk_action(pos)

	if is_queued then
		nav_link.element.value = function (element, name)
			return element[name]
		end
		nav_link.element.nav_link_wants_align_pos = nav_link.element.nav_link_wants_align_pos or function (element)
			slot4 = "[CopActionWalk:sync_action_walk_nav_link()] Appending something that is not nav_link"
			slot7 = self

			Application.debug(slot2, Application, inspect(slot6))

			return true
		end
		slot11 = nav_link

		table.insert(nav_link.element.nav_link_wants_align_pos or function (element)
			slot4 = "[CopActionWalk:sync_action_walk_nav_link()] Appending something that is not nav_link"
			slot7 = self

			Application.debug(slot2, Application, inspect(slot6))

			return true
		end, walk_action.nav_path)
	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 35-36, warpins: 1 ---
		if walk_action then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 37-41, warpins: 1 ---
			slot11 = nav_link

			walk_action.append_nav_point(slot9, walk_action)
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 42-49, warpins: 1 ---
			slot15 = anim_index

			print(slot9, self._unit, "[CopMovement:sync_action_walk_nav_link] no walk action!!!", self._unit, pos, rot)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	return 
end
CopMovement.sync_action_walk_stop = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	slot3 = self
	local walk_action, is_queued = self._get_latest_walk_action(slot2)

	if is_queued then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-19, warpins: 1 ---
		slot5 = walk_action.nav_path
		slot8 = walk_action.nav_path[#walk_action.nav_path]

		table.insert(slot4, CopActionWalk._nav_point_pos(slot7))

		walk_action.persistent = nil
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 20-21, warpins: 1 ---
		if walk_action then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 22-25, warpins: 1 ---
			slot5 = walk_action

			walk_action.stop(slot4)
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 26-29, warpins: 1 ---
			slot6 = self._unit

			print(slot4, "[CopMovement:sync_action_walk_stop] no walk action!!!")
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 30-30, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
CopMovement.sync_action_tase_end = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot5 = true

	self._cancel_latest_action(slot2, self, "tase")

	return 
	--- END OF BLOCK #0 ---



end
CopMovement.sync_pose = function (self, pose_code)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot4 = self._ext_damage

	if self._ext_damage.dead(slot3) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 7-7, warpins: 1 ---
		return 
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 8-9, warpins: 2 ---
	local pose = (pose_code == 1 and "stand") or "crouch"
	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 13-19, warpins: 2 ---
	local new_action_data = {
		body_part = 4
	}
	new_action_data.type = pose
	slot7 = new_action_data

	self.action_request(slot5, self)

	return 
	--- END OF BLOCK #2 ---



end
CopMovement.sync_action_act_start = function (self, index, blocks_hurt, clamp_to_graph, needs_full_blend, start_rot, start_pos)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot9 = self._ext_damage

	if self._ext_damage.dead(slot8) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 7-7, warpins: 1 ---
		return 
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 8-23, warpins: 2 ---
	slot10 = index
	local redir_name = self._actions.act._get_act_name_from_index(slot8, self._actions.act)
	local action_data = {
		type = "act",
		body_part = 1
	}
	action_data.variant = redir_name
	action_data.blocks = {
		act = -1,
		idle = -1,
		action = -1,
		walk = -1
	}
	action_data.start_rot = start_rot
	action_data.start_pos = start_pos
	action_data.clamp_to_graph = clamp_to_graph
	action_data.needs_full_blend = needs_full_blend

	if blocks_hurt then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 24-38, warpins: 1 ---
		action_data.blocks.light_hurt = -1
		action_data.blocks.hurt = -1
		action_data.blocks.heavy_hurt = -1
		action_data.blocks.expl_hurt = -1
		action_data.blocks.fire_hurt = -1
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 39-43, warpins: 2 ---
	slot12 = action_data

	self.action_request(slot10, self)

	return 
	--- END OF BLOCK #2 ---



end
CopMovement.sync_action_act_end = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	slot3 = self
	local act_action, queued = self._get_latest_act_action(slot2)

	if queued then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-8, warpins: 1 ---
		act_action.host_expired = true
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 9-10, warpins: 1 ---
		if act_action then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 11-16, warpins: 1 ---
			self._active_actions[1] = false

			if act_action.on_exit then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 17-19, warpins: 1 ---
				slot5 = act_action

				act_action.on_exit(slot4)
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 20-27, warpins: 2 ---
			slot5 = self

			self._chk_start_queued_action(slot4)

			slot6 = act_action

			self._ext_brain.on_action_completed(slot4, self._ext_brain)
			--- END OF BLOCK #1 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 28-28, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
CopMovement.sync_action_dodge_start = function (self, body_part, var, side, rot, speed, shoot_acc)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot9 = self._ext_damage

	if self._ext_damage.dead(slot8) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 7-7, warpins: 1 ---
		return 
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 8-33, warpins: 2 ---
	local action_data = {
		type = "dodge"
	}
	action_data.body_part = body_part
	slot10 = var
	action_data.variation = CopActionDodge.get_variation_name(slot9)
	slot10 = rot
	slot10 = Rotation(slot9)
	action_data.direction = Rotation(slot9).y(slot9)
	slot10 = side
	action_data.side = CopActionDodge.get_side_name(slot9)
	action_data.speed = speed
	action_data.shoot_accuracy = shoot_acc
	slot11 = action_data

	self.action_request(slot9, self)

	return 
	--- END OF BLOCK #1 ---



end
CopMovement.sync_action_dodge_end = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	slot4 = "dodge"

	self._cancel_latest_action(slot2, self)

	return 
	--- END OF BLOCK #0 ---



end
CopMovement.sync_action_aim_end = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	slot5 = true

	self._cancel_latest_action(slot2, self, "shoot")

	return 
	--- END OF BLOCK #0 ---



end
CopMovement.sync_action_hurt_end = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 6-17, warpins: 0 ---
	for i = #self._queued_actions, 1, -1 do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-10, warpins: 2 ---
		if self._queued_actions[i].type == "hurt" then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 11-16, warpins: 1 ---
			slot8 = i

			table.remove(slot6, self._queued_actions)

			return 
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 17-17, warpins: 2 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 18-21, warpins: 1 ---
	local action = self._active_actions[1]

	if action then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 22-26, warpins: 1 ---
		slot4 = action

		if action.type(slot3) == "hurt" then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 27-32, warpins: 1 ---
			self._active_actions[1] = false

			if action.on_exit then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 33-35, warpins: 1 ---
				slot4 = action

				action.on_exit(slot3)
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 36-40, warpins: 2 ---
			slot4 = action
			local hurt_type = action.hurt_type(slot3)

			if hurt_type == "bleedout" or hurt_type == "fatal" then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 43-51, warpins: 2 ---
				local action_data = {
					client_interrupt = true,
					type = "act",
					body_part = 1,
					variant = "stand"
				}
				action_data.blocks = {
					heavy_hurt = -1,
					hurt = -1,
					action = -1,
					stand = -1,
					light_hurt = -1,
					aim = -1,
					crouch = -1,
					walk = -1
				}
				slot7 = action_data
				slot4 = CopMovement.action_request(slot5, self)
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 52-59, warpins: 1 ---
				slot5 = self

				self._chk_start_queued_action(slot4)

				slot6 = action

				self._ext_brain.on_action_completed(slot4, self._ext_brain)
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #1 ---

			FLOW; TARGET BLOCK #2



			-- Decompilation error in this vicinity:
			--- BLOCK #2 60-60, warpins: 2 ---
			return 
			--- END OF BLOCK #2 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 61-71, warpins: 3 ---
	slot6 = inspect(slot7)
	slot9 = self._active_actions

	debug_pause(slot3, "[CopMovement:sync_action_hurt_end] no queued or ongoing hurt action", self._unit, inspect(self._queued_actions))

	return 
	--- END OF BLOCK #3 ---



end
CopMovement.enable_update = function (self, force_head_upd)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if not self._need_upd then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-12, warpins: 1 ---
		slot6 = true

		self._unit.set_extension_update_enabled(slot3, self._unit, ids_movement)

		self._need_upd = true
		self._force_head_upd = force_head_upd
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 13-13, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end
CopMovement.ground_ray = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	return self._gnd_ray
	--- END OF BLOCK #0 ---



end
CopMovement.on_nav_link_unregistered = function (self, element_id)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-4, warpins: 1 ---
	slot4 = self._active_actions

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 5-15, warpins: 0 ---
	for body_part, action in pairs(slot3) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 5-6, warpins: 1 ---
		if action and action.on_nav_link_unregistered then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 10-13, warpins: 1 ---
			slot10 = element_id

			action.on_nav_link_unregistered(slot8, action)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 14-15, warpins: 4 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 16-16, warpins: 1 ---
	return 
	--- END OF BLOCK #2 ---



end
CopMovement.pre_destroy = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-10, warpins: 1 ---
	slot4 = self

	tweak_data.remove_reload_callback(slot2, tweak_data)

	slot3 = self._rope

	if alive(slot2) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 11-19, warpins: 1 ---
		slot3 = self._rope
		slot3 = self._rope.base(slot2)

		self._rope.base(slot2).retract(slot2)

		self._rope = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 20-22, warpins: 2 ---
	if self._nav_tracker then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 23-30, warpins: 1 ---
		slot4 = self._nav_tracker

		managers.navigation.destroy_nav_tracker(slot2, managers.navigation)

		self._nav_tracker = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 31-33, warpins: 2 ---
	if self._pos_rsrv_id then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 34-41, warpins: 1 ---
		slot4 = self._pos_rsrv_id

		managers.navigation.release_pos_reservation_id(slot2, managers.navigation)

		self._pos_rsrv_id = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 42-44, warpins: 2 ---
	if self._link_data then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 45-60, warpins: 1 ---
		slot3 = self._link_data.parent
		slot9 = unit
		slot4 = "CopMovement" .. tostring(unit.key(slot8))

		self._link_data.parent.base(slot2).remove_destroy_listener(slot2, self._link_data.parent.base(slot2))
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #3 ---

	FLOW; TARGET BLOCK #4



	-- Decompilation error in this vicinity:
	--- BLOCK #4 61-67, warpins: 2 ---
	slot3 = self

	self._destroy_gadgets(slot2)

	slot3 = self._active_actions

	--- END OF BLOCK #4 ---

	FLOW; TARGET BLOCK #5



	-- Decompilation error in this vicinity:
	--- BLOCK #5 68-77, warpins: 0 ---
	for i_action, action in ipairs(slot2) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 68-69, warpins: 1 ---
		if action and action.on_destroy then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 73-75, warpins: 1 ---
			slot8 = action

			action.on_destroy(slot7)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 76-77, warpins: 4 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #5 ---

	FLOW; TARGET BLOCK #6



	-- Decompilation error in this vicinity:
	--- BLOCK #6 78-82, warpins: 1 ---
	slot4 = self._attention

	self._remove_attention_destroy_listener(slot2, self)

	return 
	--- END OF BLOCK #6 ---



end
CopMovement.on_anim_act_clbk = function (self, anim_act)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-4, warpins: 1 ---
	slot4 = self._active_actions

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 5-15, warpins: 0 ---
	for body_part, action in ipairs(slot3) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 5-6, warpins: 1 ---
		if action and action.anim_act_clbk then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 10-13, warpins: 1 ---
			slot10 = anim_act

			action.anim_act_clbk(slot8, action)
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 14-15, warpins: 4 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 16-16, warpins: 1 ---
	return 
	--- END OF BLOCK #2 ---



end
CopMovement.clbk_sync_attention = function (self, attention)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	slot4 = self._unit

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 13-15, warpins: 2 ---
	if self._attention ~= attention then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 16-16, warpins: 1 ---
		return 
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 17-19, warpins: 2 ---
	if attention.handler then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 20-28, warpins: 1 ---
		slot4 = attention.handler
		slot4 = attention.handler.unit(slot3)

		if attention.handler.unit(slot3).id(slot3) ~= -1 then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 29-39, warpins: 1 ---
			slot8 = attention.handler

			self._ext_network.send(slot3, self._ext_network, "set_attention", attention.handler.unit(attention.reaction))
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 40-52, warpins: 1 ---
			slot5 = "cop_set_attention_pos"
			slot10 = attention.handler

			self._ext_network.send(slot3, self._ext_network, mvector3.copy(attention.handler.get_attention_m_pos(slot9)))
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 53-56, warpins: 1 ---
		if self._attention.unit then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 57-62, warpins: 1 ---
			slot4 = attention.unit

			if attention.unit.id(slot3) ~= -1 then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 63-71, warpins: 1 ---
				slot7 = AIAttentionObject.REACT_IDLE

				self._ext_network.send(slot3, self._ext_network, "set_attention", self._attention.unit)
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 72-72, warpins: 5 ---
	return 
	--- END OF BLOCK #3 ---



end
CopMovement.set_team = function (self, team_data)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-12, warpins: 1 ---
	self._team = team_data
	slot5 = team_data

	self._ext_brain.on_team_set(slot3, self._ext_brain)

	slot4 = Network

	if Network.is_server(slot3) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 13-18, warpins: 1 ---
		slot4 = self._unit

		if self._unit.id(slot3) ~= -1 then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 19-27, warpins: 1 ---
			slot5 = team_data.id
			local team_index = tweak_data.levels.get_team_index(slot3, tweak_data.levels)

			if team_index <= 256 then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 28-34, warpins: 1 ---
				slot7 = team_index

				self._ext_network.send(slot4, self._ext_network, "sync_char_team")
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 35-39, warpins: 1 ---
				slot7 = team_data.id

				debug_pause_unit(slot4, self._unit, "[CopMovement:set_team] team limit reached!")
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 40-40, warpins: 4 ---
	return 
	--- END OF BLOCK #1 ---



end
CopMovement.team = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	return self._team
	--- END OF BLOCK #0 ---



end
CopMovement.anim_clbk_open_parachute = function (self, unit)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-52, warpins: 1 ---
	slot6 = unit

	Application.debug(slot3, Application, "[CopMovement:anim_clbk_open_parachute]")

	slot10 = 100
	slot5 = self._unit.position("units/vanilla/props/props_parachute/props_parachute") + Vector3(self._unit, 0, 0)
	self._parachute_unit = safe_spawn_unit(slot3, Idstring("[CopMovement:anim_clbk_open_parachute]"), self._unit.rotation(self._unit))
	slot7 = "a_weapon_left_front"
	slot6 = self._parachute_unit
	slot9 = "rp_props_parachute"

	self._unit.link(slot3, self._unit, Idstring(self._unit.rotation), Idstring(self._unit))

	slot4 = self._parachute_unit
	slot5 = "animation_unfold"

	self._parachute_unit.damage(slot3).run_sequence_simple(slot3, self._parachute_unit.damage(slot3))

	slot5 = self._parachute_unit

	managers.worldcollection.register_spawned_unit_on_last_world(slot3, managers.worldcollection)

	return 
	--- END OF BLOCK #0 ---



end
CopMovement.is_parachuting = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	slot3 = self._parachute_unit

	if alive(slot2) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-11, warpins: 1 ---
		slot3 = self._parachute_unit
		slot1 = not self._parachute_unit.unit_data(slot2).closed
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 12-12, warpins: 2 ---
	return slot1
	--- END OF BLOCK #1 ---



end
CopMovement.anim_clbk_close_parachute = function (self, unit)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	if managers.worldcollection.level_transition_in_progress then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-6, warpins: 1 ---
		return 
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 7-11, warpins: 2 ---
	slot4 = self._parachute_unit

	if alive(slot3) then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 12-18, warpins: 1 ---
		slot4 = self._parachute_unit

		if not self._parachute_unit.unit_data(slot3).closed then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 19-38, warpins: 1 ---
			slot4 = self._parachute_unit
			self._parachute_unit.unit_data(slot3).closed = true
			local position = self._parachute_unit.position(true)
			local rotation = self._parachute_unit.rotation(self._parachute_unit)
			slot6 = self._parachute_unit

			self._parachute_unit.unlink(self._parachute_unit)

			if not unit then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 39-47, warpins: 1 ---
				slot6 = self._parachute_unit
				slot7 = "make_dynamic_death"

				self._parachute_unit.damage(slot5).run_sequence_simple(slot5, self._parachute_unit.damage(slot5))
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 48-55, warpins: 1 ---
				slot6 = self._parachute_unit
				slot7 = "make_dynamic"

				self._parachute_unit.damage(slot5).run_sequence_simple(slot5, self._parachute_unit.damage(slot5))
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 56-56, warpins: 4 ---
	return 
	--- END OF BLOCK #2 ---



end
CopMovement.enter_turret_animation = function (self, anim_name, callback)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	if not anim_name then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 3-4, warpins: 1 ---
		if callback then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 5-7, warpins: 1 ---
			callback()
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 8-17, warpins: 1 ---
		slot6 = "animation"

		self._unit.set_driving(slot4, self._unit)

		slot6 = anim_name

		self.play_redirect(slot4, self)

		self._turret_enter_anim_callback = callback
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 18-18, warpins: 3 ---
	return 
	--- END OF BLOCK #1 ---



end
CopMovement.on_anim_turret_enter_finished = function (self, unit, param1)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-8, warpins: 1 ---
	self._active_actions = {
		false,
		false,
		false,
		false
	}
	slot5 = self

	self.set_attention(slot4)

	if self._turret_enter_anim_callback then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 9-10, warpins: 1 ---
		self._turret_enter_anim_callback()
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 11-11, warpins: 2 ---
	return 
	--- END OF BLOCK #1 ---



end
CopMovement.on_anim_turret_mg34_exit_finished = function (self, unit, param1)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-8, warpins: 1 ---
	slot5 = self._unit
	slot5 = self._unit.inventory(slot4)

	self._unit.inventory(slot4).show_equipped_unit(slot4)

	return 
	--- END OF BLOCK #0 ---



end
CopMovement.on_anim_turret_flakvierling_exit_finished = function (self, unit, param1)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-8, warpins: 1 ---
	slot5 = self._unit
	slot5 = self._unit.inventory(slot4)

	self._unit.inventory(slot4).show_equipped_unit(slot4)

	return 
	--- END OF BLOCK #0 ---



end

return 
